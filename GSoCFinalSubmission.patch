# This is the patch containing all my changes for the import wizard during
# the Google Summer of Code 2012 coding period. There are many changes to files
# in here that I omitted from this repository (many Makefile changes, etc.)

diff --git a/chat/Makefile.in b/chat/Makefile.in
--- a/chat/Makefile.in
+++ b/chat/Makefile.in
@@ -21,16 +21,17 @@ ifdef MOZ_DEBUG
 PROTOCOLS += jsTest
 endif
 
 PREF_JS_EXPORTS = $(srcdir)/chat-prefs.js
 
 PARALLEL_DIRS	= \
 		components/public \
 		components/src \
+		content \
+		importers \
+		locales \
 		modules \
-		content \
+		$(foreach proto,$(PROTOCOLS),protocols/$(proto)) \
 		themes \
-		locales \
-		$(foreach proto,$(PROTOCOLS),protocols/$(proto)) \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff --git a/chat/components/public/Makefile.in b/chat/components/public/Makefile.in
--- a/chat/components/public/Makefile.in
+++ b/chat/components/public/Makefile.in
@@ -13,16 +13,17 @@ MODULE		= chat
 
 XPIDLSRCS	= \
 		imIAccount.idl \
 		imIAccountsService.idl \
 		imICommandsService.idl \
 		imIContactsService.idl \
 		imIConversationsService.idl \
 		imICoreService.idl \
+		imIImportersService.idl \
 		imILogger.idl \
 		imIStatusInfo.idl \
 		imITagsService.idl \
 		imIUserStatusInfo.idl \
 		prplIConversation.idl \
 		prplIMessage.idl \
 		prplIPref.idl \
 		prplIProtocol.idl \
diff --git a/chat/components/public/imIImportersService.idl b/chat/components/public/imIImportersService.idl
new file mode 100644
--- /dev/null
+++ b/chat/components/public/imIImportersService.idl
@@ -0,0 +1,89 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+#include "nsISimpleEnumerator.idl"
+#include "nsIObserver.idl"
+#include "imIAccount.idl"
+
+[scriptable, uuid(c6363da8-04a9-4347-972a-8940ded9cde0)]
+interface imIExistingAccount: nsISupports {
+  readonly attribute AUTF8String name;
+  readonly attribute AUTF8String protocolId;
+  readonly attribute AUTF8String importerId;
+
+  // This time is used to approximate which account is more relevant if a
+  // conflict occurs. A value of 0 indicates this is unknown.
+  attribute PRTime dateModified;
+
+  attribute boolean autoLogin;
+  attribute AUTF8String password;
+  attribute AUTF8String alias;
+
+  // returns an enumerator of prplIPref containing default values set different
+  // than the protocol defaults.
+  nsISimpleEnumerator getOptions();
+
+  // Set the protocol specific options
+  void setBool(in string aName, in boolean aVal);
+  void setInt(in string aName, in long aVal);
+  void setString(in string aName, in AUTF8String aVal);
+};
+
+[scriptable, uuid(59fd4143-c8ab-4e55-b139-98b57e10bcee)]
+interface imIImporter: nsISupports {
+  readonly attribute AUTF8String name;
+  readonly attribute AUTF8String id;
+
+  // Searches for accounts configured by the client software.
+  // When found, the imIImportersService is notified.
+  //
+  // Supported notifications:
+  //  importer-found-account
+  //    aSubject points to the imImportedAccount found.
+  //  importer-search-finished
+  void findAccounts(in nsIObserver aObserver);
+
+  // Handles the task of importing data for an account found from findAccounts.
+  // This method should update its status after completing a task by notifying
+  // 'import-status-updated' with any needed status information in aData.
+  //
+  // Supported notifications:
+  //  import-status-updated
+  //    aSubject is the aAccount which owns the data.
+  //    aData is the preference string with updated status.
+  void importData(in imIAccount aAccount, in string aPreference,
+                  in nsIObserver aObserver);
+};
+
+[scriptable, uuid(d1f32c53-2272-4852-9564-4ab00f92b4dd)]
+interface imIImportersService: nsISupports {
+  // Sets the service to observe idle notifications if pending importable data
+  // remains.
+  void initImporters();
+
+  // Closes any observation of idle notifications.
+  void unInitImporters();
+
+  // Returns an instance of an imIImporter based on ID.
+  imIImporter getImporterById(in AUTF8String aImporterId);
+
+  // Each importer checks for available accounts.
+  // The observer (UI) will be notified of new accounts discovered.
+  //
+  // Supported notifications:
+  //  existing-account-found
+  //    aSubject points to the imImportedAccount found.
+  //  account-search-finished
+  void findAccounts(in nsIObserver aObserver);
+
+  // When an account is created, it must be queued for importing data. This
+  // creates the preference indicating an awaiting import.
+  void queueAccount(in string aAccountId, in string aImporterId);
+
+  // observe should only be called by the imIImporter implementations to report
+  // changes.
+  void observe(in nsISupports aObject, in string aTopic,
+               [optional] in wstring aData);
+};
diff --git a/chat/components/public/imILogger.idl b/chat/components/public/imILogger.idl
--- a/chat/components/public/imILogger.idl
+++ b/chat/components/public/imILogger.idl
@@ -37,19 +37,23 @@ interface imILogConversation: nsISupport
 interface imILog: nsISupports {
   readonly attribute AUTF8String path;
   readonly attribute PRTime time;
   readonly attribute AUTF8String format;
   // Will return null if the log format isn't json.
   imILogConversation getConversation();
 };
 
-[scriptable, uuid(ab38c01c-2245-4279-9437-1d6bcc69d556)]
+[scriptable, uuid(f038b621-6419-475d-9621-e86ba055f777)]
 interface imILogger: nsISupports {
   imILog getLogFromFile(in nsIFile aFile);
   nsIFile getLogFileForOngoingConversation(in prplIConversation aConversation);
   nsISimpleEnumerator getLogsForAccountBuddy(in imIAccountBuddy aAccountBuddy);
   nsISimpleEnumerator getLogsForBuddy(in imIBuddy aBuddy);
   nsISimpleEnumerator getLogsForContact(in imIContact aContact);
   nsISimpleEnumerator getLogsForConversation(in prplIConversation aConversation);
   nsISimpleEnumerator getSystemLogsForAccount(in imIAccount aAccount);
   nsISimpleEnumerator getSimilarLogs(in imILog aLog);
+
+  // Adds a conversation manually, optionally dated in the past.
+  void logConversation(in prplIConversation aConversation,
+                       [optional] in PRTime aDate);
 };
diff --git a/chat/components/src/Makefile.in b/chat/components/src/Makefile.in
--- a/chat/components/src/Makefile.in
+++ b/chat/components/src/Makefile.in
@@ -10,13 +10,14 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 EXTRA_COMPONENTS = \
 		imAccounts.js imAccounts.manifest \
 		imCommands.js imCommands.manifest \
 		imContacts.js imContacts.manifest \
 		imConversations.js imConversations.manifest \
 		imCore.js imCore.manifest \
+		imImporters.js imImporters.manifest \
 		logger.js logger.manifest \
 		smileProtocolHandler.js smileProtocolHandler.manifest \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff --git a/chat/components/src/imCore.js b/chat/components/src/imCore.js
--- a/chat/components/src/imCore.js
+++ b/chat/components/src/imCore.js
@@ -261,16 +261,17 @@ CoreService.prototype = {
         Services.obs.notifyObservers(aSubject, aTopic, aData);
       }
     });
 
     let accounts = Services.accounts;
     accounts.initAccounts();
     Services.contacts.initContacts();
     Services.conversations.initConversations();
+    Services.importers.initImporters();
     Services.obs.notifyObservers(this, "prpl-init", null);
 
     if (accounts.autoLoginStatus == Ci.imIAccountsService.AUTOLOGIN_ENABLED)
       accounts.processAutoLogin();
   },
   observe: function(aObject, aTopic, aData) {
     if (aTopic == kQuitApplicationGranted)
       this.quit();
@@ -281,16 +282,17 @@ CoreService.prototype = {
 
     Services.obs.removeObserver(this, kQuitApplicationGranted);
     Services.obs.notifyObservers(this, "prpl-quit", null);
 
     Services.conversations.unInitConversations();
     Services.accounts.unInitAccounts();
     Services.contacts.unInitContacts();
     Services.cmd.unInitCommands();
+    Services.importers.unInitImporters();
 
     this.globalUserStatus.unInit();
     delete this.globalUserStatus;
     delete this._protos;
     delete this._initialized;
   },
 
   getProtocols: function() {
diff --git a/chat/components/src/imImporters.js b/chat/components/src/imImporters.js
new file mode 100644
--- /dev/null
+++ b/chat/components/src/imImporters.js
@@ -0,0 +1,226 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+
+XPCOMUtils.defineLazyServiceGetter(this, "categoryManager",
+                                   "@mozilla.org/categorymanager;1",
+                                   "nsICategoryManager");
+
+const kImporterPluginCategory = "im-import-plugin";
+const kImportIdleSeconds = 60;
+
+function ImportersService() { }
+ImportersService.prototype = {
+  // Called when the core initializes. If data importing has not been completed,
+  // it will be scheduled in the idleService.
+  initImporters: function() {
+    let enabled = Services.prefs.getBoolPref("messenger.importWizard.enabled");
+    if (this._pendingImport() && enabled)
+      this._monitorIdleness();
+  },
+
+  unInitImporters: function() {
+    if (this._monitoringIdleness) {
+      this._idleService.removeIdleObserver(this, kImportIdleSeconds);
+      this._monitoringIdleness = false;
+      this._idleService = null;
+    }
+  },
+
+  _idle: false,
+  _monitoringIdleness: false,
+  _monitorIdleness: function() {
+    if (this._monitoringIdleness)
+      return;
+    this._idleService = Cc["@mozilla.org/widget/idleservice;1"]
+                          .getService(Ci.nsIIdleService);
+    this._idleService.addIdleObserver(this, kImportIdleSeconds);
+    this._monitoringIdleness = true;
+  },
+
+  // Determines whether there is data awaiting import.
+  _pendingImport: function() {
+    let accounts = Services.prefs.getCharPref("messenger.accounts").split(",");
+    for each (let accountId in accounts) {
+      let prefName = "messenger.account." + accountId + ".import";
+      if (Services.prefs.prefHasUserValue(prefName))
+        return true;
+    }
+    return false;
+  },
+
+  findAccounts: function(aObserver) {
+    this._findAccObserver = aObserver;
+
+    // Locate the registered importers and create instances.
+    this._importers = [];
+    let importers = this.getImporters();
+    while (importers.hasMoreElements())
+      this._importers.push(importers.getNext().QueryInterface(Ci.imIImporter));
+
+    // If there are no importers registered, the observer still needs a signal.
+    if (!this._importers.length) {
+      this._findAccObserver.observe(this, "account-search-finished", null);
+      return;
+    }
+
+    // Call the account search method on each importer. The use of executeSoon
+    // is to prevent race conditions when calling observe() on the UI from the
+    // importers.
+    for each (let importer in this._importers) {
+      try {
+        let findAccounts = importer.findAccounts;
+        executeSoon(function() {
+          try {
+            findAccounts(this);
+          } catch(e) {
+            Cu.reportError("Error in importer findAccounts(): " + e.message);
+            this.observe(importer, "account-search-finished", null);
+          }
+        }.bind(this));
+      }
+      catch (e) {
+        Cu.reportError("Error calling findAccounts(): " + e.message);
+      }
+    }
+  },
+
+  queueAccount: function(aAccountId, aImporterId) {
+    let prefName = "messenger.account." + aAccountId + ".import";
+    if (Services.prefs.prefHasUserValue(prefName)) {
+      // Throw an error if the pref exists; maybe there is further action to
+      // take here? The UI should not allow the user to add the same account
+      // twice.
+      let error = "Account " + aAccountId + " has an existing importer " +
+                  "preference: " + Services.prefs.getCharPref(prefName);
+      Cu.reportError(error);
+      return;
+    }
+
+    // Write the initial import preference.
+    let pref = JSON.stringify({account: aAccountId, importer: aImporterId});
+    Services.prefs.setCharPref(prefName, pref);
+  },
+
+  observe: function(aSubject, aTopic, aData) {
+    if (aTopic === "existing-account-found") {
+      this._findAccObserver.observe(aSubject, "existing-account-found", null);
+    }
+    else if (aTopic === "account-search-finished") {
+      let importerIndex = this._importers.indexOf(aSubject);
+      if (importerIndex !== -1)
+        this._importers.splice(importerIndex, 1);
+      if (!this._importers.length)
+        this._findAccObserver.observe(this, "account-search-finished", null);
+    }
+    else if (aTopic === "import-status-updated") {
+      let [account, pref] = [aSubject, aData];
+      let prefName = "messenger.account." + account.id + ".import";
+
+      // The import is finished for this account.
+      if (!pref) {
+        Services.prefs.clearUserPref(prefName);
+        return;
+      }
+      Services.prefs.setCharPref(prefName, pref);
+
+      // The user has returned from idle, yet importing remains. The
+      // next task will be postponed until idle occurs again.
+      if (!this._idle)
+        return;
+
+      let importer = this.getImporterById(JSON.parse(pref).importer);
+      let importData = importer.importData;
+      executeSoon(function() {
+        try {
+          importData(account, pref, this);
+        } catch(e) {
+          Cu.reportError("Error in importer importData(): " + e.message);
+        }
+      }.bind(this));
+    }
+    else if (aTopic === "idle") {
+      this._idle = true;
+
+      // If we have received this notification and there is no pending import,
+      // the idle observation can be removed; it would be added again if new
+      // accounts were selected for import.
+      if (!this._pendingImport()) {
+        this.unInitImporters();
+        return;
+      }
+
+      let accts = Services.prefs.getCharPref("messenger.accounts").split(",");
+      for each (let accountId in accts) {
+        // Check accounts for the pref indicating awaiting importable data.
+        let prefName = "messenger.account." + accountId + ".import";
+        if (!Services.prefs.prefHasUserValue(prefName))
+          continue;
+
+        let dataObj = Services.prefs.getCharPref(prefName);
+        dataObj = JSON.parse(dataObj);
+
+        // Distribute initial call to import the data. The service observer
+        // will make future calls as necessary.
+        let account = Services.accounts.getAccountById(accountId);
+        let importer = this.getImporterById(dataObj.importer);
+        let importData = importer.importData;
+        executeSoon(function() {
+          try {
+            importData(account, JSON.stringify(dataObj), this);
+          } catch(e) {
+            Cu.reportError("Error in importer importData(): " + e.message);
+          }
+        }.bind(this));
+      }
+    }
+    else if (aTopic === "back")
+      this._idle = false;
+  },
+
+  getImporters: function() {
+    let importers = [];
+    let entries = categoryManager.enumerateCategory(kImporterPluginCategory);
+    while (entries.hasMoreElements()) {
+      let id = entries.getNext().QueryInterface(Ci.nsISupportsCString).data;
+      let importer = this.getImporterById(id);
+      if (importer)
+        importers.push(importer);
+    }
+    return new nsSimpleEnumerator(importers);
+  },
+
+  getImporterById: function(aImporterId) {
+    let cid;
+    try {
+      cid = categoryManager.getCategoryEntry(kImporterPluginCategory, aImporterId);
+    } catch (e) {
+      return null; // no importer registered for this id.
+    }
+
+    let importer = null;
+    try {
+      importer = Cc[cid].createInstance(Ci.imIImporter);
+    } catch (e) {
+      // This is a real error, the importer is registered and failed to init.
+      let error = "failed to create an instance of " + cid + ": " + e;
+      Cu.reportError(error);
+    }
+    if (!importer)
+      return null;
+
+    return importer;
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImportersService]),
+  classDescription: "Importers",
+  classID: Components.ID("{d1f32c53-2272-4852-9564-4ab00f92b4dd}"),
+  contractID: "@mozilla.org/chat/importers-service;1"
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([ImportersService]);
diff --git a/chat/components/src/imImporters.manifest b/chat/components/src/imImporters.manifest
new file mode 100644
--- /dev/null
+++ b/chat/components/src/imImporters.manifest
@@ -0,0 +1,2 @@
+component {d1f32c53-2272-4852-9564-4ab00f92b4dd} imImporters.js
+contract @mozilla.org/chat/importers-service;1 {d1f32c53-2272-4852-9564-4ab00f92b4dd}
diff --git a/chat/components/src/logger.js b/chat/components/src/logger.js
--- a/chat/components/src/logger.js
+++ b/chat/components/src/logger.js
@@ -22,34 +22,52 @@ const ConverterInputStream = CC("@mozill
                                 "nsIConverterInputStream",
                                 "init");
 const LocalFile = CC("@mozilla.org/file/local;1",
                      "nsILocalFile",
                      "initWithPath");
 
 const kLineBreak = "@mozilla.org/windows-registry-key;1" in Cc ? "\r\n" : "\n";
 
+function encodeName(aName){
+  // Reserved device names by Windows.
+  let reservedNames = ["CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3",
+    "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3",
+    "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"];
+  if (reservedNames.indexOf(aName.toUpperCase()) != -1)
+    return "%" + aName;
+  // "." and " " mustnâ€™t be at the end of a file or folder name, appending "_".
+  if (/[\. _]/.test(aName.slice(-1)))
+    aName += "_";
+  // Reserved characters are replaced by %[hex value]. encodeURIComponent() is
+  // not sufficient, nevertheless decodeURIComponent() can be used to decode.
+  function encodeReservedChars(match) "%" + match.charCodeAt(0).toString(16);
+  return aName.replace(/[<>:"\/\\|?*&%]/g, encodeReservedChars);
+}
+
 function getLogFolderForAccount(aAccount, aCreate)
 {
   let file = logDir.clone();
   function createIfNotExists(aFile) {
     if (aCreate && !aFile.exists())
       aFile.create(Ci.nsIFile.DIRECTORY_TYPE, 0777);
   }
   createIfNotExists(file);
   file.append(aAccount.protocol.normalizedName);
   createIfNotExists(file);
-  file.append(aAccount.normalizedName);
+  file.append(encodeName(aAccount.normalizedName));
   createIfNotExists(file);
   return file;
 }
 
-function getNewLogFileName(aFormat)
+function getNewLogFileName(aFormat, aDate)
 {
   let date = new Date();
+  if (aDate)
+    date = aDate;
   let dateTime = date.toLocaleFormat("%Y-%m-%d.%H%M%S");
   let offset = date.getTimezoneOffset();
   if (offset < 0) {
     dateTime += "+";
     offset *= -1;
   }
   else
     dateTime += "-";
@@ -57,64 +75,81 @@ function getNewLogFileName(aFormat)
   offset = (offset - minutes) / 60;
   function twoDigits(aNumber)
     aNumber == 0 ? "00" : aNumber < 10 ? "0" + aNumber : aNumber;
   if (!aFormat)
     aFormat = "txt";
   return dateTime + twoDigits(offset) + twoDigits(minutes) + "." + aFormat;
 }
 
+// Performs the disk writing of the log files
+function LogWriter(aFile) {
+  let outputStream = Cc["@mozilla.org/network/file-output-stream;1"].
+             createInstance(Ci.nsIFileOutputStream);
+  const PR_WRITE_ONLY   = 0x02;
+  const PR_CREATE_FILE  = 0x08;
+  const PR_APPEND       = 0x10;
+  outputStream.init(aFile, PR_WRITE_ONLY | PR_CREATE_FILE | PR_APPEND, 0666, 0);
+  // just to be really sure everything is in UTF8
+  let converter = Cc["@mozilla.org/intl/converter-output-stream;1"].
+                  createInstance(Ci.nsIConverterOutputStream);
+  converter.init(outputStream, "UTF-8", 0, 0);
+  this._output = converter;
+}
+LogWriter.prototype = {
+  writeMessage: function(aString) {
+    this._output.writeString(aString);
+  },
+  close: function() {
+    if (this._output) {
+      this._output.close();
+      this._output = null;
+    }
+  }
+};
+
 /* Conversation logs stuff */
-function ConversationLog(aConversation)
+function ConversationLog(aConversation, aDate)
 {
   this._conv = aConversation;
+  this._date = aDate;
 }
 ConversationLog.prototype = {
   _log: null,
   file: null,
   format: "txt",
   _init: function cl_init() {
     let file = getLogFolderForAccount(this._conv.account, true);
     let name = this._conv.normalizedName;
     if (this._conv.isChat && this._conv.account.protocol.id != "prpl-twitter")
       name += ".chat";
-    file.append(name);
+    file.append(encodeName(name));
     if (!file.exists())
       file.create(Ci.nsIFile.DIRECTORY_TYPE, 0777);
     if (Services.prefs.getCharPref("purple.logging.format") == "json")
       this.format = "json";
-    file.append(getNewLogFileName(this.format));
+    file.append(getNewLogFileName(this.format, this._date));
     this.file = file;
-    let os = Cc["@mozilla.org/network/file-output-stream;1"].
-             createInstance(Ci.nsIFileOutputStream);
-    const PR_WRITE_ONLY   = 0x02;
-    const PR_CREATE_FILE  = 0x08;
-    const PR_APPEND       = 0x10;
-    os.init(file, PR_WRITE_ONLY | PR_CREATE_FILE | PR_APPEND, 0666, 0);
-    // just to be really sure everything is in UTF8
-    let converter = Cc["@mozilla.org/intl/converter-output-stream;1"].
-                    createInstance(Ci.nsIConverterOutputStream);
-    converter.init(os, "UTF-8", 0, 0);
-    this._log = converter;
-    this._log.writeString(this._getHeader());
+    this._log = new LogWriter(file);
+    this._log.writeMessage(this._getHeader());
   },
   _getHeader: function cl_getHeader()
   {
     let account = this._conv.account;
     if (this.format == "json") {
-      return JSON.stringify({date: new Date(),
+      return JSON.stringify({date: (this._date ? this._date : new Date()),
                              name: this._conv.name,
                              title: this._conv.title,
                              account: account.normalizedName,
                              protocol: account.protocol.normalizedName,
                              isChat: this._conv.isChat
                             }) + "\n";
     }
     return "Conversation with " + this._conv.name +
-           " at " + (new Date).toLocaleString() +
+           " at " + (this._date ? this._date : new Date()).toLocaleString() +
            " on " + account.name +
            " (" + account.protocol.normalizedName + ")" + kLineBreak;
   },
   _serialize: function cl_serialize(aString) {
     // TODO cleanup once bug 102699 is fixed
     let doc = getHiddenHTMLWindow().document;
     let div = doc.createElementNS("http://www.w3.org/1999/xhtml", "div");
     div.innerHTML = aString.replace(/\r?\n/g, "<br/>").replace(/<br>/gi, "<br/>");
@@ -147,17 +182,17 @@ ConversationLog.prototype = {
         flags: ["outgoing", "incoming", "system", "autoResponse",
                 "containsNick", "error", "delayed",
                 "noFormat", "containsImages", "notification",
                 "noLinkification"].filter(function(f) aMessage[f])
       };
       let alias = aMessage.alias;
       if (alias && alias != msg.who)
         msg.alias = alias;
-      this._log.writeString(JSON.stringify(msg) + "\n");
+      this._log.writeMessage(JSON.stringify(msg) + "\n");
       return;
     }
 
     let date = new Date(aMessage.time * 1000);
     let line = "(" + date.toLocaleTimeString() + ") ";
     let msg = this._serialize(aMessage.originalMessage);
     if (aMessage.system)
       line += msg;
@@ -167,17 +202,18 @@ ConversationLog.prototype = {
         line += sender + " <AUTO-REPLY>: " + msg;
       else {
         if (/^\/me /.test(msg))
           line += "***" + sender + " " + msg.replace(/^\/me /, "");
         else
           line += sender + ": " + msg;
       }
     }
-    this._log.writeString(line + kLineBreak);
+    //this._log.writeString(line + kLineBreak);
+    this._log.writeMessage(line + kLineBreak);
   },
 
   close: function cl_close() {
     if (this._log) {
       this._log.close();
       this._log = null;
       this.file = null;
     }
@@ -213,47 +249,38 @@ function closeLogForConversation(aConver
   gConversationLogs[id].close();
   delete gConversationLogs[id];
 }
 
 /* System logs stuff */
 function SystemLog(aAccount)
 {
   this._init(aAccount);
-  this._log.writeString("System log for account " + aAccount.name +
+  this._log.writeMessage("System log for account " + aAccount.name +
                         " (" + aAccount.protocol.normalizedName +
                         ") connected at " +
                         (new Date()).toLocaleFormat("%c") + kLineBreak);
 }
 SystemLog.prototype = {
   _log: null,
   _init: function sl_init(aAccount) {
     let file = getLogFolderForAccount(aAccount, true);
     file.append(".system");
     if (!file.exists())
       file.create(Ci.nsIFile.DIRECTORY_TYPE, 0777);
     file.append(getNewLogFileName());
-    let os = Cc["@mozilla.org/network/file-output-stream;1"].
-             createInstance(Ci.nsIFileOutputStream);
-    const PR_WRITE_ONLY   = 0x02;
-    const PR_CREATE_FILE  = 0x08;
-    const PR_APPEND       = 0x10;
-    os.init(file, PR_WRITE_ONLY | PR_CREATE_FILE | PR_APPEND, 0666, 0);
-    // just to be really sure everything is in UTF8
-    let converter = Cc["@mozilla.org/intl/converter-output-stream;1"].
-                    createInstance(Ci.nsIConverterOutputStream);
-    converter.init(os, "UTF-8", 0, 0);
-    this._log = converter;
+    this._log = new LogWriter(file);
   },
   logEvent: function sl_logEvent(aString) {
     if (!this._log)
       this._init();
 
     let date = (new Date()).toLocaleFormat("%x %X");
-    this._log.writeString("---- " + aString + " @ " + date + " ----" + kLineBreak);
+    let message = "---- " + aString + " @ " + date + " ----" + kLineBreak;
+    this._log.writeMessage(message);
   },
 
   close: function sl_close() {
     if (this._log) {
       this._log.close();
       this._log = null;
     }
   }
@@ -386,42 +413,42 @@ LogEnumerator.prototype = {
     new Log(this._entries[0].getNext().QueryInterface(Ci.nsIFile)),
   QueryInterface: XPCOMUtils.generateQI([Ci.nsISimpleEnumerator])
 };
 
 function Logger() { }
 Logger.prototype = {
   _enumerateLogs: function logger__enumerateLogs(aAccount, aNormalizedName) {
     let file = getLogFolderForAccount(aAccount);
-    file.append(aNormalizedName);
+    file.append(encodeName(aNormalizedName));
     if (!file.exists())
       return EmptyEnumerator;
 
     return new LogEnumerator([file.directoryEntries]);
   },
   getLogFromFile: function logger_getLogFromFile(aFile) new Log(aFile),
   getLogFileForOngoingConversation: function logger_getLogFileForOngoingConversation(aConversation)
     getLogForConversation(aConversation).file,
   getLogsForContact: function logger_getLogsForContact(aContact) {
     let entries = [];
     aContact.getBuddies().forEach(function (aBuddy) {
       aBuddy.getAccountBuddies().forEach(function (aAccountBuddy) {
         let file = getLogFolderForAccount(aAccountBuddy.account);
-        file.append(aAccountBuddy.normalizedName);
+        file.append(encodeName(aAccountBuddy.normalizedName));
         if (file.exists())
           entries.push(file.directoryEntries);
       });
     });
     return new LogEnumerator(entries);
   },
   getLogsForBuddy: function logger_getLogsForBuddy(aBuddy) {
     let entries = [];
     aBuddy.getAccountBuddies().forEach(function (aAccountBuddy) {
       let file = getLogFolderForAccount(aAccountBuddy.account);
-      file.append(aAccountBuddy.normalizedName);
+      file.append(encodeName(aAccountBuddy.normalizedName));
       if (file.exists())
         entries.push(file.directoryEntries);
     });
     return new LogEnumerator(entries);
   },
   getLogsForAccountBuddy: function logger_getLogsForAccountBuddy(aAccountBuddy)
     this._enumerateLogs(aAccountBuddy.account, aAccountBuddy.normalizedName),
   getLogsForConversation: function logger_getLogsForConversation(aConversation) {
@@ -431,16 +458,31 @@ Logger.prototype = {
       name += ".chat";
     return this._enumerateLogs(aConversation.account, name);
   },
   getSystemLogsForAccount: function logger_getSystemLogsForAccount(aAccount)
     this._enumerateLogs(aAccount, ".system"),
   getSimilarLogs: function(aLog)
     new LogEnumerator([new LocalFile(aLog.path).parent.directoryEntries]),
 
+  // Adds a conversation not notifying the global observer service.
+  logConversation: function(aConversation, aDate) {
+    aConversation.QueryInterface(Ci.prplIConversation);
+    let id = aConversation.id;
+    if (!(id in gConversationLogs)) {
+      if (aDate)
+        aDate = new Date(aDate);
+      let prefName =
+        "purple.logging.log_" + (aConversation.isChat ? "chats" : "ims");
+      if (Services.prefs.getBoolPref(prefName))
+        gConversationLogs[id] = new ConversationLog(aConversation, aDate);
+    }
+    aConversation.addObserver(this);
+  },
+
   observe: function logger_observe(aSubject, aTopic, aData) {
     switch (aTopic) {
     case "profile-after-change":
       Services.obs.addObserver(this, "final-ui-startup", false);
       break;
     case "final-ui-startup":
       Services.obs.removeObserver(this, "final-ui-startup");
       ["new-text", "conversation-closed", "conversation-left-chat",
diff --git a/chat/importers/Makefile.in b/chat/importers/Makefile.in
new file mode 100644
--- /dev/null
+++ b/chat/importers/Makefile.in
@@ -0,0 +1,37 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH		= ../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+EXTRA_COMPONENTS = \
+		pidgin.js pidgin.manifest \
+		xchat.js xchat.manifest \
+		$(NULL)
+
+ifeq ($(OS_ARCH),WINNT)
+EXTRA_COMPONENTS += \
+		aim.js aim.manifest \
+		googletalk.js googletalk.manifest \
+		mIRC.js mIRC.manifest \
+		wlm.js wlm.manifest \
+		$(NULL)
+endif
+
+ifeq ($(OS_ARCH),Darwin)
+EXTRA_COMPONENTS += \
+		colloquy.js colloquy.manifest \
+		$(NULL)
+endif
+
+ifdef ENABLE_TESTS
+relativesrcdir = chat/importers/
+XPCSHELL_TESTS = test
+endif
+
+include $(topsrcdir)/config/rules.mk
diff --git a/chat/importers/aim.js b/chat/importers/aim.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/aim.js
@@ -0,0 +1,240 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsImporterHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+Cu.import("resource://gre/modules/NetUtil.jsm");
+Cu.import("resource:///modules/blowfish.jsm");
+
+/* The importer below contains methods to retrieve configured
+ * AIM 6.x accounts.
+ *
+ * Homepage: http://www.aim.com/
+ * Resources:
+ *   A summary of the AIM Blowfish key generation.
+ *     http://insecurety.net/?p=112
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation which can locate AIM usernames and
+ *     passwords from the Windows registry.
+ */
+function aim6Importer() { }
+aim6Importer.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "AIM 6.x",
+  get id() "importer-aim6x",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    // AIM 6.x stores user account information in the Windows registry:
+    // HKU\Software\America Online\AIM6\Passwords
+    const ACCESS_READ = Ci.nsIWindowsRegKey.ACCESS_READ;
+    let swKey = Cc["@mozilla.org/windows-registry-key;1"]
+                  .createInstance(Ci.nsIWindowsRegKey);
+    swKey.open(swKey.ROOT_KEY_CURRENT_USER, "Software", ACCESS_READ);
+    if (!swKey.hasChild("America Online")) {
+      this._endAccountSearch();
+      return;
+    }
+    let aolKey = swKey.openChild("America Online", ACCESS_READ);
+    if (!aolKey.hasChild("AIM6")) {
+      this._endAccountSearch();
+      return;
+    }
+    let aimKey = aolKey.openChild("AIM6", ACCESS_READ);
+    if (!aimKey.hasChild("Passwords")) {
+      this._endAccountSearch();
+      return;
+    }
+    let passwordsKey = aimKey.openChild("Passwords", ACCESS_READ);
+
+    // Within the Passwords key, each value represents an account. The name of
+    // each value is an AIM username, and the string value is the user's
+    // encrypted password base64 encoded.
+    for (let i = 0; i < passwordsKey.valueCount; ++i) {
+      let username = passwordsKey.getValueName(i);
+      let foundAccount = new ExistingAccount(username, "prpl-aim", this.id);
+
+      // Decode and decrypt the user's password.
+      let encodedPass = passwordsKey.readStringValue(username);
+      let decodedPass = atob(encodedPass);
+      foundAccount.password = this.decryptPassword(decodedPass);
+
+      this._returnAccount(foundAccount);
+    }
+
+    // Close the handles on the Windows registry.
+    passwordsKey.close();
+    aimKey.close();
+    aolKey.close();
+    swKey.close();
+    this._endAccountSearch();
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{2aa7b114-6937-4eab-bb5e-f4ff874a2a77}")
+};
+aim6Importer.prototype.decryptPassword = decryptPassword;
+
+/* The importer below contains methods to retrieve configured
+ * AIM 7.x accounts.
+ *
+ * Homepage: http://www.aim.com/
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation reading the username and password of a
+ *     saved AIM 7.x account.
+ */
+function aim7Importer() { }
+aim7Importer.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "AIM 7.x",
+  get id() "importer-aim7x",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    let aimxfile = this._getAIMXFile();
+    if (!aimxfile.exists()) {
+      this._endAccountSearch();
+      return;
+    }
+
+    // Asynchronously read the aimx.bin file into a stream and run it through a
+    // parsing function.
+    NetUtil.asyncFetch(aimxfile, this._parseAIMXFile.bind(this));
+  },
+
+  _parseAIMXFile: function(stream, status) {
+    if (!Components.isSuccessCode(status)) {
+      this._endAccountSearch();
+      return;
+    }
+
+    // A StreamListener implementation is needed to receive the asynchronously
+    // decompressed string.
+    let myListener = new StreamListener();
+
+    // The aimx.bin file is compressed with DEFLATE. The asynchronous method
+    // of nsIStreamConverter must be used as the synchronous is not implemented.
+    let converter = Cc["@mozilla.org/streamconv;1?from=deflate&to=uncompressed"]
+                      .createInstance(Ci.nsIStreamConverter);
+    converter.asyncConvertData("deflate", "uncompressed", myListener, null);
+    converter.onStartRequest(null, null);
+    converter.onDataAvailable(null, null, stream, 0, stream.available());
+    converter.onStopRequest(null, null, 201);
+
+    // The result of the uncompression is a string containing an AIM username
+    // and Base64 encoded password separated by '-'.
+    let decompressed = myListener.data;
+    let userData = decompressed.split("-");
+
+    // Catch any invalid data
+    if (userData.length !== 2 || !userData[0] || !userData[1]) {
+      this._endAccountSearch();
+      return;
+    }
+
+    let [username, encodedPass] = userData;
+    let foundAccount= new ExistingAccount(username, "prpl-aim", this.id);
+
+    // Base64 decode the password string and Blowfish decrypt the blocks.
+    let encodedPass = encodedPass.slice(0, encodedPass.length - 3);
+    let decodedPass = atob(encodedPass);
+    foundAccount.password = this.decryptPassword(decodedPass);
+
+    this._returnAccount(foundAccount);
+    this._endAccountSearch();
+  },
+
+  // AIM 7.x stores the saved login information in an "aimx.bin" file found in
+  // the user's AppData/Local directory. This file has been gzip compressed, but
+  // without the full gzip heading. Once uncompressed, this file contains a
+  // username and base64 encoded encrypted password. The encryption is the same
+  // that AIM 6.x uses.
+  _getAIMXFile: function() {
+    let aimxFile = Services.dirsvc.get("LocalAppData", Ci.nsIFile);
+    aimxFile.append("AIM");
+    aimxFile.append("aimx.bin");
+    return aimxFile.clone();
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{0eb885e8-1fa2-4761-ada1-8a44ee339ec4}")
+};
+aim7Importer.prototype.decryptPassword = decryptPassword;
+
+// AIM6 and AIM7 use the same Blowfish encryption techniques.
+// This method handles calls to the Blowfish cipher module, and returns the
+// user's plaintext password. It is called with the encrypted password text.
+function decryptPassword(aPassword) {
+  // Read the individual character codes from the encrypted password string.
+  let passArray = [aPassword.charCodeAt(i) for (i in aPassword)];
+
+  // The first 8 bytes of the encrypted password string are a "salt". To
+  // create the Blowfish key, this salt is prepended to a known static key,
+  // creating a 448-bit key, the maximum allowed by a Blowfish implementation.
+  let salt = passArray.slice(0, 8);
+  let key =
+    salt.concat([0x99, 0x00, 0x86, 0xA5, 0x27, 0xAA, 0x9D, 0x7F, 0x58, 0xAA,
+                 0xAE, 0xB9, 0x0B, 0x47, 0x3A, 0x35, 0xAA, 0xE0, 0xEA, 0x95,
+                 0x66, 0xFB, 0xE4, 0x9F, 0xCB, 0xF7, 0x16, 0x1C, 0xA3, 0x92,
+                 0xE6, 0x1C, 0x96, 0x06, 0x9B, 0x5B, 0x29, 0x30, 0xBF, 0xAF,
+                 0xEC, 0x11, 0x29, 0xC8, 0x89, 0x5B, 0xB8, 0x57]);
+  key = Uint8Array(key);
+
+  // TODO: Use of DataView in Mozilla 15 should eliminate this function.
+  let _swapEndianness = function(aWord) {
+    return ((aWord & 0xFF) << 24) | ((aWord & 0xFF00) << 8)
+           | ((aWord >> 8) & 0xFF00) | ((aWord >> 24) & 0xFF);
+  };
+
+  // The remainder of the encrypted password string after the salt is the
+  // password itself.
+  let pass = Uint32Array(Uint8Array(passArray.slice(8)).buffer);
+  for (let i = 0; i < pass.length; ++i)
+    pass[i] = _swapEndianness(pass[i]);
+  pass = Uint8Array(pass.buffer);
+
+  // The Blowfish cipher takes and outputs Uint8Array values.
+  let blowfish = new Blowfish(key);
+  let output = blowfish.decrypt(pass);
+
+  output = Uint32Array(output.buffer);
+  for (let i = 0; i < output.length; ++i)
+    output[i] = _swapEndianness(output[i]);
+
+  // Convert the typed array of Unicode bytes into a string.
+  pass = String.fromCharCode.apply(null, new Uint16Array(output.buffer));
+
+  // Remove any low ASCII values, trailing 0x00s can occur and cause errors.
+  return pass.split("").filter(function(e) e.charCodeAt(0) >= 0x20).join("");
+};
+
+// StreamListener implementation for AIM 7.x file decompression.
+function StreamListener() {
+  this.data = "";
+}
+StreamListener.prototype = {
+  onStartRequest: function(aReq, aContext) { },
+  onStopRequest: function(aReq, aContext, aStatusCode) { },
+  onDataAvailable: function(aReq, aContext, aInputStream, aOffset, aCount) {
+    let binInputStream = Cc["@mozilla.org/binaryinputstream;1"]
+                           .createInstance(Ci.nsIBinaryInputStream);
+    binInputStream.setInputStream(aInputStream);
+    let input = binInputStream.readByteArray(aCount);
+
+    // Filter out lower ASCII values that can result after uncompression.
+    input = input.filter(function(e) e >= 0x20);
+    this.data += String.fromCharCode.apply(String, input);
+    binInputStream.close();
+  }
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([aim6Importer,
+                                                      aim7Importer]);
diff --git a/chat/importers/aim.manifest b/chat/importers/aim.manifest
new file mode 100644
--- /dev/null
+++ b/chat/importers/aim.manifest
@@ -0,0 +1,6 @@
+component {2aa7b114-6937-4eab-bb5e-f4ff874a2a77} aim.js
+contract @mozilla.org/chat/aim6ximporter;1 {2aa7b114-6937-4eab-bb5e-f4ff874a2a77}
+category im-import-plugin importer-aim6x @mozilla.org/chat/aim6ximporter;1
+component {0eb885e8-1fa2-4761-ada1-8a44ee339ec4} aim.js
+contract @mozilla.org/chat/aim7ximporter;1 {0eb885e8-1fa2-4761-ada1-8a44ee339ec4}
+category im-import-plugin importer-aim7x @mozilla.org/chat/aim7ximporter;1
diff --git a/chat/importers/colloquy.js b/chat/importers/colloquy.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/colloquy.js
@@ -0,0 +1,119 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsImporterHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+Cu.import("resource://gre/modules/NetUtil.jsm");
+
+// The PropertyListUtils object allows access to OS X property list files,
+// handling the details of parsing the various formats in existance.
+XPCOMUtils.defineLazyModuleGetter(this, "PropertyListUtils",
+                                  "resource://gre/modules/PropertyListUtils.jsm");
+
+/* The importer below contains methods to retrieve configured Colloquy IRC
+ * accounts.
+ *
+ * Homepage: http://colloquy.info/
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation reading the available IRC accounts from
+ *     the Colloquy configuration property list.
+ */
+function colloquyImporter() { }
+colloquyImporter.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "Colloquy",
+  get id() "importer-colloquy",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    let propFile = this._getColloquyConfiguration();
+    if (!propFile.exists()) {
+      this._endAccountSearch();
+      return;
+    }
+
+    // Asynchronously read the info.colloquy.plist file and run it through a
+    // parsing function.
+    PropertyListUtils.read(propFile, this._parseColloquyProperties.bind(this));
+    return;
+  },
+
+  _parseColloquyProperties: function(aPropertiesRoot) {
+    // The properties file was not properly parsed.
+    if (!aPropertiesRoot) {
+      this._endAccountSearch();
+      Cu.reportError("Could not read Colloquy property list");
+      return;
+    }
+
+    // The properties list does not have a MVChatBookmarks entry
+    if (!aPropertiesRoot.has("MVChatBookmarks")) {
+      this._endAccountSearch();
+      return;
+    }
+
+    let accounts = aPropertiesRoot.get("MVChatBookmarks");
+    for each (let account in accounts) {
+      // Colloquy website says there is IRC, SILC, and ICB support.
+      // TODO: Are XMPP settings supported?
+      if (!account.has("type"))
+        continue;
+      let type;
+      switch(account.get("type")) {
+        case "irc":
+          type = "prpl-irc";
+          break;
+        default:
+          continue;
+      }
+
+      // Read the username and server keys from the account dictionary.
+      let username, server;
+      if (account.has("username"))
+        username = account.get("username");
+      if (account.has("server"))
+        server = account.get("server");
+
+      if (!username || !server)
+        continue;
+
+      let accountName = username + "@" + server;
+      let foundAccount = new ExistingAccount(accountName, type, this.id);
+
+      if (account.has("port")) {
+        let port = parseInt(account.get("port"));
+        foundAccount.setInt("port", port);
+      }
+
+      if (account.has("secure")) {
+        let ssl = account.get("secure");
+        foundAccount.setBool("ssl", !!ssl);
+      }
+
+      this._returnAccount(foundAccount);
+    }
+
+    this._endAccountSearch();
+  },
+
+  // Colloquy stores a property list of settings in
+  // ~/Library/Preferences/info.colloquy.plist
+  _getColloquyConfiguration: function() {
+    let colloquyInfo = Services.dirsvc.get("Home", Ci.nsIFile);
+    colloquyInfo.append("Library");
+    colloquyInfo.append("Preferences");
+    colloquyInfo.append("info.colloquy.plist");
+    return colloquyInfo;
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{d89d3c75-bb22-4a1b-9078-19361b5e2b8a}")
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([colloquyImporter]);
diff --git a/chat/importers/colloquy.manifest b/chat/importers/colloquy.manifest
new file mode 100644
--- /dev/null
+++ b/chat/importers/colloquy.manifest
@@ -0,0 +1,3 @@
+component {d89d3c75-bb22-4a1b-9078-19361b5e2b8a} colloquy.js
+contract @mozilla.org/chat/colloquyimporter;1 {d89d3c75-bb22-4a1b-9078-19361b5e2b8a}
+category im-import-plugin importer-colloquy @mozilla.org/chat/colloquyimporter;1
diff --git a/chat/importers/googletalk.js b/chat/importers/googletalk.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/googletalk.js
@@ -0,0 +1,229 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsImporterHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+Cu.import("resource://gre/modules/ctypes.jsm");
+
+/* The importer below contains methods to retrieve configured
+ * Google Talk client accounts.
+ *
+ * Homepage: http://www.google.com/talk/
+ * Resources:
+ *   A good summary of the password generation algorithm.
+ *     http://insecurety.net/?p=137
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation locating the username and password of
+ *     the currently saved GTalk credentials.
+ */
+function googleTalkImporter() { }
+googleTalkImporter.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "Google Talk",
+  get id() "importer-googletalk",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    const ACCESS_READ = Ci.nsIWindowsRegKey.ACCESS_READ;
+    let swKey = Cc["@mozilla.org/windows-registry-key;1"]
+                  .createInstance(Ci.nsIWindowsRegKey);
+    swKey.open(swKey.ROOT_KEY_CURRENT_USER, "Software", ACCESS_READ);
+    if (!swKey.hasChild("Google")) {
+      this._endAccountSearch();
+      return;
+    }
+    let googleKey = swKey.openChild("Google", ACCESS_READ);
+    if (!googleKey.hasChild("Google Talk")) {
+      this._endAccountSearch();
+      return;
+    }
+    let gtalkKey = googleKey.openChild("Google Talk", ACCESS_READ);
+    if (!gtalkKey.hasChild("Accounts")) {
+      this._endAccountSearch();
+      return;
+    }
+    let accountsKey = gtalkKey.openChild("Accounts", ACCESS_READ);
+
+    for (let i = 0; i < accountsKey.childCount; ++i) {
+      let username = accountsKey.getChildName(i);
+      let foundAccount = new ExistingAccount(username, "prpl-gtalk", this.id);
+
+      let child = accountsKey.openChild(username, ACCESS_READ);
+      if (child.hasValue("pw")) {
+        foundAccount.password = this._decryptPass(child.readStringValue("pw"));
+        // If the 'pw' value exists, the account is set to auto-login
+        foundAccount.autoLogin = true;
+      }
+      this._returnAccount(foundAccount);
+    }
+
+    accountsKey.close();
+    gtalkKey.close();
+    googleKey.close();
+    swKey.close();
+    this._endAccountSearch();
+  },
+
+  // The first step towards decrypting (or encrypting) a Google Talk saved
+  // password is to create the entropy data, 16 bytes that are unique based on
+  // the user's username and domain.
+  _initializeEntropy: function() {
+    // These values are read from environment variables.
+    const username = this._getCurrentUser();
+    const domain = this._getCurrentDomain();
+
+    // The entropy and seed start out with certain values.
+    let entropy = Uint32Array([0x69F31EA3, 0x1FD96207, 0x7D35E91E, 0x487DD24F]);
+    let seed = 0xBA0DA71D;
+    // TODO: (Gecko 15) Consider using DataView to avoid 32-bit math issues.
+
+    // Establish the multiplier for modifying the entropy and seed.
+    const multiplier = 48271;
+    // Create an array of the username and domain character code values.
+    const combinedString = username + domain;
+    const charCodes = [combinedString.charCodeAt(i) for (i in combinedString)];
+
+    // Mix the character code values into the entropy.
+    let index = 0;
+    for each (let charcode in charCodes) {
+      entropy[index++ % 4] ^= (charcode * seed);
+      seed = (seed * multiplier) >>> 0;
+    }
+
+    // The entropy returned is an Uint32Array.
+    return entropy;
+  },
+
+  // After the entropy has been created, the custom Base16 password string read
+  // from the registry can be decoded into binary data.
+  _decodePasswordString: function(aPassword, aEntropy) {
+    // Google uses the following character alphabet in their Base16 encoding.
+    const alphabet = "!\"#$%&'()*+,-./0";
+
+    // A separate seed is initialized using the entropy.
+    // TODO: (Gecko 15) Consider using DataView to avoid 32-bit math issues.
+    let seed = aEntropy[0] | 1;
+    const multiplier = 69621;
+
+    // After the decoding below, the encrypted password will be half the length
+    // of the original encoded string.
+    let decodedPass = new Uint8Array(aPassword.length / 2);
+    let passIndex = 0;
+    for (let i = 4; i < aPassword.length; i += 2) {
+      decodedPass[passIndex] = alphabet.indexOf(aPassword[i]) << 4;
+      decodedPass[passIndex] |= alphabet.indexOf(aPassword[i + 1]) & 0x0F;
+      decodedPass[passIndex++] -= (seed & 0xFF);
+      seed = (seed * multiplier) >>> 0;
+    }
+
+    // The decoded password returned is an Uint8Array.
+    return decodedPass;
+  },
+
+  _cryptUnprotectData: function(aDataIn, aDataEntropy) {
+    let crypt32 = ctypes.open("Crypt32");
+
+    // The DATA_BLOB struct contains an "arbitrary array of bytes."
+    // http://msdn.microsoft.com/en-us/library/aa381414.aspx
+    const DATA_BLOB = ctypes.StructType("DATA_BLOB", [
+      {'cbData': ctypes.uint32_t},         // Data size (in bytes)
+      {'pbData': ctypes.unsigned_char.ptr} // Pointer to data
+    ]);
+
+    let CryptUnprotectData = crypt32.declare("CryptUnprotectData",
+      ctypes.winapi_abi,
+      ctypes.bool,
+      DATA_BLOB.ptr,      // *pDataIn
+      ctypes.unsigned_char.ptr,  // null (description)
+      DATA_BLOB.ptr,      // *pOptionalEntropy
+      ctypes.voidptr_t,   // null
+      ctypes.voidptr_t,   // null
+      ctypes.uint32_t,    // dwFlags
+      DATA_BLOB.ptr       // *pDataOut
+    );
+
+    // Create a DATA_BLOB of the input password entry.
+    let inputArray = [aDataIn[i] for (i in aDataIn)];
+    let dataInArray = ctypes.unsigned_char.array(inputArray.length)(inputArray);
+    let dataInBlob = DATA_BLOB(dataInArray.length, dataInArray.addressOfElement(0));
+
+    // Create a DATA_BLOB of the entropy data. The array of 32-bit entropy must
+    // now be converted to a 16 byte 8-bit array.
+    let dataEntropyArray = ctypes.unsigned_char.array(16)();
+    let x = 0;
+    for (let i = 0; i < aDataEntropy.length; i++) {
+      for (let j = 0; j < 4; j++) {
+        dataEntropyArray[x++] = ctypes.unsigned_char(aDataEntropy[i] & 255);
+        if (j !== 3)
+          aDataEntropy[i] = aDataEntropy[i] >> 8;
+      }
+    }
+    let dataEntropyBlob = DATA_BLOB(dataEntropyArray.length,
+                                    dataEntropyArray.addressOfElement(0));
+
+    // Create a DATA_BLOB to be filled with the plaintext information.
+    let dataOutBlob = DATA_BLOB();
+    let result = CryptUnprotectData(dataInBlob.address(),
+                                    null,
+                                    dataEntropyBlob.address(),
+                                    null,
+                                    null,
+                                    1,
+                                    dataOutBlob.address());
+
+    if (!result) {
+      let e = "importer-googletalk CryptUnprotectData: " + ctypes.winLastError;
+      Cu.reportError(e);
+      return "";
+    }
+
+    let passArray = ctypes.cast(dataOutBlob.pbData,
+                                ctypes.unsigned_char.array(dataOutBlob.cbData).ptr);
+    let password = passArray.contents.readString();
+
+    crypt32.close();
+
+    // The memory handle to the dataOutBlob must be freed.
+    let kernel32 = ctypes.open("Kernel32");
+    let LocalFree = kernel32.declare("LocalFree",
+      ctypes.winapi_abi,
+      ctypes.voidptr_t,
+      ctypes.voidptr_t
+    );
+    LocalFree(dataOutBlob.pbData);
+    kernel32.close();
+
+    return password;
+  },
+
+  // This method ties together the entropy creation, password decoding, and
+  // decryption using CryptUnprotectData.
+  _decryptPass: function(aPassword) {
+    let entropy = this._initializeEntropy();
+    let decodedPass = this._decodePasswordString(aPassword, entropy);
+    return this._cryptUnprotectData(decodedPass, entropy);
+  },
+
+  _getCurrentUser: function() {
+    let envService = Cc["@mozilla.org/process/environment;1"]
+                       .getService(Ci.nsIEnvironment);
+    return envService.get("USERNAME");
+  },
+
+  _getCurrentDomain: function() {
+    let envService = Cc["@mozilla.org/process/environment;1"]
+                       .getService(Ci.nsIEnvironment);
+    return envService.get("USERDOMAIN");
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{24df4c97-6526-4938-9880-f88d9013910d}")
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([googleTalkImporter]);
diff --git a/chat/importers/googletalk.manifest b/chat/importers/googletalk.manifest
new file mode 100644
--- /dev/null
+++ b/chat/importers/googletalk.manifest
@@ -0,0 +1,3 @@
+component {24df4c97-6526-4938-9880-f88d9013910d} googletalk.js
+contract @mozilla.org/chat/googletalkimporter;1 {24df4c97-6526-4938-9880-f88d9013910d}
+category im-import-plugin importer-googletalk @mozilla.org/chat/googletalkimporter;1
diff --git a/chat/importers/mIRC.js b/chat/importers/mIRC.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/mIRC.js
@@ -0,0 +1,524 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsImporterHelper.jsm");
+Cu.import("resource:///modules/jsProtoHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "_", function()
+  l10nHelper("chrome://chat/locale/irc.properties")
+);
+
+/* The importer below contains methods to retrieve the current IRC account from
+ * the Windows IRC client mIRC.
+ *
+ * Homepage: http://www.mirc.com/
+ * Resources:
+ *   A reference to the "mirc.ini" file format.
+ *     http://www.mirc-support.de/help/mircini/
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation reading the user and host IRC information
+ *     along with supported preferences.
+ *   - An importData() implementation parsing the mIRC logs for the currently
+ *     configured account.
+ */
+function mIRCImporter() { }
+mIRCImporter.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "mIRC",
+  get id() "importer-mirc",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    let mircConfig = this._getMircConfiguration();
+    if (!mircConfig.exists()) {
+      this._endAccountSearch();
+      return;
+    }
+
+    let mircIniFile = this._createINIFile(mircConfig);
+    let user = this._getINIValue(mircIniFile, "mirc", "nick");
+    let server = this._getINIValue(mircIniFile, "mirc", "host");
+
+    // An IRC account cannot be created without both name and server.
+    if (!user || !server) {
+      this._endAccountSearch();
+      return;
+    }
+
+    // Parse the unusual server string format.
+    let serverInfo = this._parseServerString(server);
+
+    // If this occurs, there must be an error with either the INI
+    // or the parse method.
+    if (!serverInfo.host) {
+      let e = "importer-mirc: Error parsing server string \"" + server + "\"";
+      Cu.reportError(e);
+      this._endAccountSearch();
+      return;
+    }
+
+    let name = user + "@" + serverInfo.host;
+    let foundAccount = new ExistingAccount(name, "prpl-irc", this.id);
+
+    if (serverInfo.port)
+      foundAccount.setInt("port", serverInfo.port);
+
+    let quitmsg = this._getINIValue(mircIniFile, "text", "quit");
+    if (quitmsg)
+      foundAccount.setString("quitmsg", quitmsg);
+
+    let optList = this._getINIValue(mircIniFile, "options", "n0");
+    if (optList)
+      foundAccount.autoLogin = (optList[0] == "1");
+
+    this._returnAccount(foundAccount);
+    this._endAccountSearch();
+  },
+
+  importData: function(aAccount, aPreference, aObserver) {
+    this._observer = aObserver;
+
+    let pref = JSON.parse(aPreference);
+    if (!pref.initialized) {
+      let updatedPref = JSON.stringify(this._initImport(pref));
+      this._updateImportStatus(aAccount, updatedPref);
+      return;
+    }
+
+    if (!pref.fileInProgress) {
+      // If we have finished a file previously and there are no more remaining,
+      // the import is finished!
+      if (!pref.logFiles.length) {
+        this._updateImportStatus(aAccount, null);
+        return;
+      }
+
+      pref.fileInProgress = pref.logFiles[0];
+      pref.filePosition = 0x00;
+      pref.logFiles = pref.logFiles.slice(1);
+    }
+
+    let logFile = Cc["@mozilla.org/file/local;1"]
+                    .createInstance(Ci.nsILocalFile);
+    logFile.initWithPath(pref.fileInProgress);
+
+    // Create a stream to read lines from the log files from the last offset.
+    let logStream = Cc["@mozilla.org/network/file-input-stream;1"]
+                      .createInstance(Ci.nsIFileInputStream);
+    logStream.init(logFile, 0x1, 0, 0);
+    logStream.QueryInterface(Ci.nsISeekableStream);
+    logStream.seek(0, pref.filePosition);
+    logStream.QueryInterface(Ci.nsILineInputStream);
+
+    let messageRegex = /(.*)\s?<[%@\+]?(.*)>\s(.*)/;
+    let joinRegex = /(.*)\s?\*\s[%@\+]?(.*)\s\((.*)\)\shas\sjoined/;
+    let partRegex = /(.*)\s?\*\s[@%\+]?(.*)\s\((.*)\)\shas\sleft/;
+    let partReasonRegex = /(.*)\s?\*\s[@%\+]?(.*)\s\((.*)\)\shas\sleft\s.+\s\("(.*)".?\)/;
+    let quitRegex = /(.*)\s?\*\s(.*)\s\((.*)\)\sQuit\s\((.*)\x0F\)/;
+    let modeRegex = /(.*)\s?\*\s(.*)\ssets mode:\s(.*)\s(.*)/;
+    let modeChannelRegex = /(.*)\s?\*\s(.*)\ssets mode:\s(.*)/;
+    let kickRegex = /(.*)\s?\*\s(.*)\swas kicked by\s(.*)/;
+    let kickReasonRegex = /(.*)\s?\*\s(.*)\swas kicked by\s(.*)\s\((.*)\x0F\)/;
+    let systemRegex = /(.*)\s?\*\s(.*)/;
+
+    let dateRegex;
+    if (pref.timestampsEnabled)
+      dateRegex = new RegExp(pref.timestampRegex.regex);
+
+    let conversation, sessionDate, target;
+    let [line, more] = [{}, false];
+    do {
+      more = logStream.readLine(line);
+      let val = line.value;
+
+      // Update the current offset with the string length. The stream offset is
+      // not useful as it tells the buffer offset, not the single line offset.
+      pref.filePosition += (line.value.length + 2);
+
+      // Check if a new IRC session is starting.
+      if (val.indexOf("Session Start") === 0) {
+        // This would only occur with a malformed log file. Move to the next
+        // file as if EOF reached.
+        if (conversation) {
+          Cu.reportError("mIRC log malformed (conversation already opened) in "
+                         + pref.fileInProgress + " (Line: " + val);
+          break;
+        }
+
+        // Parse the conversation session date for now.
+        sessionDate = this._parseLogSessionDate(val);
+        continue;
+      }
+
+      // Read the target name and create the conversation.
+      if (val.indexOf("Session Ident") === 0) {
+        target = val.slice(val.indexOf(":") + 2);
+        let isChat = (target.indexOf("#") !== -1);
+        conversation = new ImporterConversation(target, aAccount, isChat);
+        Services.logs.logConversation(conversation, sessionDate.getTime());
+        continue;
+      }
+
+      // Conversation has come to an end.
+      if (val.indexOf("Session Close") === 0) {
+        // This would only occur with a malformed log file. Move to the next
+        // file as if EOF reached.
+        if (!conversation) {
+          Cu.reportError("mIRC log malformed (conversation not active) in "
+                         + pref.fileInProgress + " (Line: " + val);
+          break;
+        }
+        // Close the conversation in the logger and move on to the next one.
+        conversation.unInit();
+        logStream.close();
+        this._updateImportStatus(aAccount, JSON.stringify(pref));
+        return;
+      }
+
+      // Do not test for messages if there has not been a conversation opened.
+      if (!conversation)
+        continue;
+
+      // Remove unnecessary characters found at the start of some lines.
+      // Specifically, ASCII code 0x03 followed by either "02" or "03".
+      if (val.indexOf("\x03") === 0)
+        val = val.slice(3);
+
+      let date, who, text;
+      let msgObject = {};
+
+      // Parse the different possible messages in the conversation.
+      let match;
+      if ((match = val.match(messageRegex)) && match) {
+        [date, who, text] = match.slice(1);
+        msgObject.outgoing = (who == pref.nick || who == pref.anick);
+        msgObject.incoming = !msgObject.outgoing;
+      }
+      else if ((match = val.match(joinRegex)) && match) {
+        [date, who] = match.slice(1);
+        text = _("message.join", who, match[3]);
+        msgObject.system = true;
+        msgObject.noLinkification = true;
+      }
+      else if ((match = val.match(partReasonRegex)) && match) {
+        [date,, who] = match.slice(1);
+        text = _("message.parted", match[2], _("message.parted.reason", match[4]));
+        msgObject.system = true;
+      }
+      else if ((match = val.match(partRegex)) && match) {
+        [date,, who] = match.slice(1);
+        text = _("message.parted", match[2]);
+        msgObject.system = true;
+      }
+      else if ((match = val.match(quitRegex)) && match) {
+        [date, who] = [match[1], null];
+        text = _("message.quit", match[2], _("message.quit2", match[4]));
+        msgObject.system = true;
+      }
+      else if ((match = val.match(modeRegex)) && match) {
+        [date, who] = match.slice(1);
+        text = _("message.mode", match[4], match[3], who);
+        msgObject.system = true;
+      }
+      else if ((match = val.match(modeChannelRegex)) && match) {
+        [date, who] = match.slice(1);
+        text = _("message.mode", target, match[3], who);
+        msgObject.system = true;
+      }
+      else if ((match = val.match(kickReasonRegex)) && match) {
+        [date,, who] = match.slice(1);
+        text = _("message.kicked", match[2], who, _("message.kicked.reason", match[4]));
+        msgObject.system = true;
+      }
+      else if ((match = val.match(kickRegex)) && match) {
+        [date,, who] = match.slice(1);
+        text = _("message.kicked", match[2], who);
+        msgObject.system = true;
+      }
+      else if ((match = val.match(systemRegex)) && match) {
+        [date, who, text] = [match[1], null, match[2]];
+        msgObject.system = true;
+      }
+
+      if (pref.timestampsEnabled) {
+        let msgDate = this._parseMessageDate(date, sessionDate, dateRegex,
+                                             pref.timestampRegex.order);
+        msgObject.time = (msgDate / 1000);
+      }
+
+      if (text)
+        conversation.writeMessage(who, text, msgObject);
+      else
+        dump("\nUnknown message type in mIRC log file. Message: " + val);
+    } while (more);
+
+    // The EOF has been reached, prepare the pref for the next file to parse.
+    logStream.close();
+    delete pref.fileInProgress;
+    this._updateImportStatus(aAccount, JSON.stringify(pref));
+  },
+
+  _initImport: function(aPref) {
+    let mircConfig = this._getMircConfiguration();
+    if (!mircConfig.exists()) {
+      Cu.reportError("Could not read mIRC configuration file (mirc.ini)");
+      return null;
+    }
+    let mircIniFile = this._createINIFile(mircConfig);
+
+    aPref.logDirectory = this._getLogDirectory(mircIniFile);
+    if (!aPref.logDirectory) {
+      Cu.reportError("Could not locate mIRC log directory");
+      return null;
+    }
+
+    let server = this._getINIValue(mircIniFile, "mirc", "host");
+    server = this._parseServerString(server);
+    if (!server.group) {
+      Cu.reportError("Could not read group name of account");
+      return null;
+    }
+    aPref.serverGroup = server.group.toLowerCase();
+
+    aPref.nick = this._getINIValue(mircIniFile, "mirc", "nick");
+    aPref.anick = this._getINIValue(mircIniFile, "mirc", "anick");
+
+    aPref.timestampsEnabled =
+      (this._getINIValue(mircIniFile, "options", "n6").split(",")[26] === "1");
+    if (aPref.timestampsEnabled) {
+      let timestamp = this._getINIValue(mircIniFile, "text", "logstamp");
+      aPref.timestampRegex = this._createTimestampRegex(timestamp);
+    }
+
+    // Locate the log files to be imported. Being that the account imported
+    // was of a certain server group, only logs of that group will be saved.
+    let mircLogDir = Cc["@mozilla.org/file/local;1"]
+                       .createInstance(Ci.nsILocalFile);
+    mircLogDir.initWithPath(aPref.logDirectory);
+    let logFiles = mircLogDir.directoryEntries;
+    aPref.logFiles = [];
+    while (logFiles.hasMoreElements()) {
+      let logFile = logFiles.getNext().QueryInterface(Ci.nsIFile);
+      // The server group should be in the filename, but not at the beginning.
+      if (logFile.path.toLowerCase().indexOf(aPref.serverGroup) <= 0)
+        continue;
+      // The status.[group].log file is not wanted.
+      let statusName = "status." + aPref.serverGroup;
+      if (logFile.leafName.toLowerCase().indexOf(statusName) === 0)
+        continue;
+      aPref.logFiles.push(logFile.path);
+    }
+
+    aPref.initialized = true;
+    return aPref;
+  },
+
+  // The "logdir" value holds the directory where mIRC stores log files.
+  // The value may either be a relative directory or a full path.
+  _getLogDirectory: function(aMircConfIni) {
+    let logdir = this._getINIValue(aMircConfIni, "dirs", "logdir");
+    if (logdir.indexOf(":") === -1) {
+      let mircLogDir = this._getMircConfiguration().parent;
+      mircLogDir.appendRelativePath(logdir);
+      if (!mircLogDir.exists())
+        return null;
+      return mircLogDir.path;
+    }
+    return logdir;
+  },
+
+  // mIRC writes the date when a channel is entered and left in the logs. This
+  // parses that string and returns a Date object (to the nearest second).
+  _parseLogSessionDate: function(aString) {
+    let dateString = aString.replace("Session Start: ", "")
+                            .replace("Session Close: ", "");
+    return new Date(dateString);
+  },
+
+  _parseMessageDate: function(aDatestring, aSessionDate, aRegex, aOrder) {
+    let msgDate = new Date(aSessionDate.getFullYear(), aSessionDate.getMonth(),
+                           aSessionDate.getDate());
+    if (!aDatestring || !aRegex)
+      return msgDate;
+
+    let dateMatch = aDatestring.match(aRegex);
+    if (dateMatch) {
+      let matches = dateMatch.slice(1);
+
+      let longMonths =  ["January", "February", "March", "April", "May", "June",
+                         "July", "August", "September", "October", "November",
+                         "December"];
+      let shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
+                         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
+      let longDays =    ["Monday", "Tuesday", "Wednesday", "Thursday",
+                         "Friday", "Saturday", "Sunday"];
+      let shortDays =   ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
+      for (let i = 0; i < matches.length; ++i) {
+        let type = aOrder[i];
+        if (type === "year")
+          msgDate.setFullYear(parseInt(matches[i]));
+        else if (type === "month") {
+          if (longMonths.indexOf(matches[i]) !== -1)
+            msgDate.setMonth(longMonths.indexOf(matches[i]));
+          else if (shortMonths.indexOf(matches[i]) !== -1)
+            msgDate.setMonth(shortMonths.indexOf(matches[i]));
+          else
+            msgDate.setMonth(parseInt(matches[i]));
+        }
+        else if (type === "day" && !isNaN(parseInt(matches[i])))
+            msgDate.setDate(parseInt(matches[i]));
+        else if (type === "hour")
+          msgDate.setHours(parseInt(matches[i]));
+        else if (type === "minute")
+          msgDate.setMinutes(parseInt(matches[i]));
+        else if (type === "second")
+          msgDate.setSeconds(parseInt(matches[i]));
+      }
+    }
+    return msgDate;
+  },
+
+  // The user can specify a custom timestamp in mIRC's options. This will be
+  // parsed by creating a regular expression based on that timestamp mask.
+  _createTimestampRegex: function(aTimestamp) {
+    // Escape special characters of a regular expression.
+    let timestamp = aTimestamp.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
+    let regex = "";
+    let matchOrder = [];
+
+    const dateItems = [
+      { masks: ["yyyy", "yy"],             desc: "year" },
+      { masks: ["mmmm", "mmm", "mm", "m"], desc: "month" },
+      { masks: ["dddd", "ddd", "dd", "d"], desc: "day" },
+      { masks: ["HH", "H", "hh", "h"],     desc: "hour" },
+      { masks: ["nn", "n"],                desc: "minute" },
+      { masks: ["ss", "s"],                desc: "second" },
+      { masks: [],                         desc: "milliseconds" },
+      { masks: ["TT", "T", "tt", "t"],     desc: "am/pm" },
+      { masks: ["oo"],                     desc: "ordinal" },
+      { masks: ["zzz", "zz", "z"],         desc: "timezone" }
+    ];
+    const monthStringRegex = "(January|February|March|April|May|June|July|" +
+                             "August|September|October|November|December)";
+    const dayStringRegex = "(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)";
+
+    // Advance through the timestamp, checking for the date indicators.
+    let i = 0;
+    while (i < timestamp.length) {
+      let found = false;
+      for (let j = 0; j < dateItems.length; ++j) {
+        let itemTypes = dateItems[j].masks;
+        for each (let indicator in itemTypes) {
+          if (timestamp.indexOf(indicator, i) === i) {
+            found = true;
+            switch (j) {
+              case 0:
+              case 3:
+              case 4:
+              case 5:
+                regex += "(\\d{" + indicator.length + "})";
+                break;
+              case 1:
+                if (indicator.length === 4)
+                  regex += monthStringRegex;
+                else if (indicator.length === 3)
+                  regex += "([A-Z][a-z]{2})";
+                else
+                  regex += "(\\d{" + indicator.length + "})";
+                break;
+              case 2:
+                if (indicator.length === 4)
+                  regex += dayStringRegex;
+                else if (indicator.length === 3)
+                  regex += "([A-Z][a-z]{2})";
+                else
+                  regex += "(\\d{" + indicator.length + "})";
+                break;
+              case 7:
+                if (indicator.length === 1)
+                  regex += "([AaPp])";
+                else
+                  regex += "([AaPm][Mm])";
+              case 8:
+                regex += "(st|nd|rd|th)";
+                break;
+              case 9:
+                regex += "([-\\+]\\d{" + (indicator.length > 1 ? "4})" : "1})");
+                regex += (indicator.length > 2 ? "\\sGMT" : "");
+                break;
+            }
+            i += (indicator.length - 1);
+            matchOrder.push(dateItems[j].desc);
+            break;
+          }
+        }
+      }
+      // The character at index 0 is a literal in the timestamp.
+      if (!found)
+        regex += timestamp[i];
+      i++;
+    }
+    return {regex: regex, order: matchOrder};
+  },
+
+  // A typical server entry might look as such:
+  // [mirc]
+  // host=Random serverSERVER:irc.dal.net:6667GROUP:DALnet
+  _parseServerString: function(aString) {
+    // This regex matches the server host, port, and group of the server string.
+    let serverRegExp = /SERVER:([\w\.]+):?(\d*)?(?:GROUP:)?(\w*)?/
+    let result = serverRegExp.exec(aString).slice(1);
+
+    // Create an object to return the IRC host, port, and group.
+    let serverObj = {host: '', port: '', group: ''};
+    serverObj.host = result[0];
+    if (result.length > 1)
+      serverObj.port = parseInt(result[1]);
+    if (result.length > 2)
+      serverObj.group = result[2];
+    return serverObj;
+  },
+
+  // mIRC stores application settings in a "mIRC" directory found in the
+  // Windows user's AppData directory.
+  _getMircDirectory: function() {
+    let mircFolder = Services.dirsvc.get("AppData", Ci.nsIFile);
+    mircFolder.append("mIRC");
+    return mircFolder.clone();
+  },
+
+  // mIRC stores IRC account information in a "mirc.ini" found in the mIRC
+  // AppData directory.
+  _getMircConfiguration: function() {
+    let mircConfig = this._getMircDirectory();
+    mircConfig.append("mirc.ini");
+    return mircConfig.clone();
+  },
+
+  _createINIFile: function(aFile) {
+    let iniFactory = Components.manager.getClassObjectByContractID(
+                       "@mozilla.org/xpcom/ini-parser-factory;1",
+                       Ci.nsIINIParserFactory);
+    return iniFactory.createINIParser(aFile);
+  },
+
+  _getINIValue: function(aINIParser, aSection, aProperty) {
+    try {
+      return aINIParser.getString(aSection, aProperty);
+    } catch(e) {
+      return undefined;
+    }
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{f9d5e613-b320-461c-8c03-faa89afdb68c}")
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([mIRCImporter]);
diff --git a/chat/importers/mIRC.manifest b/chat/importers/mIRC.manifest
new file mode 100644
--- /dev/null
+++ b/chat/importers/mIRC.manifest
@@ -0,0 +1,3 @@
+component {f9d5e613-b320-461c-8c03-faa89afdb68c} mIRC.js
+contract @mozilla.org/chat/mircimporter;1 {f9d5e613-b320-461c-8c03-faa89afdb68c}
+category im-import-plugin importer-mirc @mozilla.org/chat/mircimporter;1
diff --git a/chat/importers/pidgin.js b/chat/importers/pidgin.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/pidgin.js
@@ -0,0 +1,364 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsImporterHelper.jsm");
+Cu.import("resource:///modules/jsProtoHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+Cu.import("resource://gre/modules/NetUtil.jsm");
+
+/* The importer below contains methods to retrieve accounts
+ * from the instant messaging client, Pidgin.
+ *
+ * Homepage: http://pidgin.im/
+ * Resources:
+ *   Summary of Pidgin's data storage.
+ *     http://developer.pidgin.im/wiki/ConfigurationFiles
+ *   An addon by waynenguyen implementing similar functionality.
+ *     https://addons.instantbird.org/en-US/instantbird/addon/314
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation capable of parsing an accounts.xml
+ *     document to locate accounts and their associated settings.
+ *   - An importData() implementation parsing plaintext and HTML log files.
+ */
+function pidginImporter() { }
+pidginImporter.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "Pidgin",
+  get id() "importer-pidgin",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    let accountFile = this._getPurpleDirectory();
+    if (!accountFile.exists() || !accountFile.isDirectory()) {
+      this._endAccountSearch();
+      return;
+    }
+    accountFile.append("accounts.xml");
+    if (!accountFile.exists()) {
+      this._endAccountSearch();
+      return;
+    }
+
+    // Asynchronously read the account.xml file into a stream and run it
+    // through a parsing function.
+    NetUtil.asyncFetch(accountFile, this._parseAccountXML.bind(this));
+  },
+
+  // This method is used by NetUtil.asyncFetch, and handles the parsing of the
+  // accounts.xml file into ExistingAccount objects.
+  _parseAccountXML: function(stream, status) {
+    if (!Components.isSuccessCode(status)) {
+      this._endAccountSearch();
+      return;
+    }
+
+    let xmlParser = Cc["@mozilla.org/xmlextras/domparser;1"]
+                      .createInstance(Ci.nsIDOMParser);
+    let accountXml
+      = xmlParser.parseFromStream(stream, null, stream.available(), "text/xml");
+    let accounts = accountXml.documentElement.getElementsByTagName("account");
+    for (let i = 0; i < accounts.length; ++i) {
+      let account = accounts[i];
+
+      let name = account.getElementsByTagName("name");
+      if (name.length)
+        name = name[0].textContent;
+
+      let protocol = account.getElementsByTagName("protocol");
+      if (protocol.length)
+        protocol = protocol[0].textContent;
+
+      // An account cannot be created if neither <name> or <protocol> tags do
+      // not exist. Pidgin supports some prpl-ids not available in Instantbird.
+      if ((!name || !protocol) || !Services.core.getProtocolById(protocol))
+        continue;
+
+      // Pidgin supports Facebook Chat/Google Talk, but uses an
+      // XMPP account instead.
+      if (protocol === "prpl-jabber") {
+        let fbRegExp = /(\w+)(?=@chat.facebook.com\/)/;
+        let gtalkRegExp = /(\w+)(?=@gmail.com|@googlemail.com)/;
+        if (fbRegExp.test(name)) {
+          name = name.match(fbRegExp)[0];
+          protocol = "prpl-facebook";
+        }
+        else if (gtalkRegExp.test(name))
+          protocol = "prpl-gtalk";
+      }
+
+      let foundAccount = new ExistingAccount(name, protocol, this.id);
+      let password = account.getElementsByTagName("password");
+      if (password.length)
+        foundAccount.password = password[0].textContent;
+
+      let alias = account.getElementsByTagName("alias");
+      if (alias.length)
+        foundAccount.alias = alias[0].textContent;
+
+      let settings = account.getElementsByTagName("settings");
+      this._parseSettings(settings, foundAccount);
+      this._returnAccount(foundAccount);
+    }
+    this._endAccountSearch();
+  },
+
+  // Pidgin stores profile information with a ".purple" directory.
+  // In Windows this directory can be found in the Roaming AppData
+  // directory. In Linux/OS X, this directory is found in the user
+  // home directory. For more information:
+  // http://developer.pidgin.im/wiki/Using%20Pidgin#Whereismy.purpledirectory
+  _getPurpleDirectory: function() {
+    // Check for a PURPLEHOME environment variable, which
+    // overrides the default location for the .purple directory.
+    let envService = Cc["@mozilla.org/process/environment;1"]
+                       .getService(Ci.nsIEnvironment);
+    if (envService.exists("PURPLEHOME")) {
+      let purpleOverride = envService.get("PURPLEHOME");
+      let purpleDir = Cc["@mozilla.org/file/local;1"]
+                        .createInstance(Ci.nsILocalFile);
+      purpleDir.initWithPath(purpleOverride);
+      purpleDir.append(".purple");
+      return purpleDir.clone();
+    }
+
+    let systemDir = (Services.appinfo.OS === "WINNT" ? "AppData" : "Home");
+    let purpleDir = Services.dirsvc.get(systemDir, Ci.nsIFile);
+    purpleDir.append(".purple");
+    return purpleDir.clone();
+  },
+
+  // Within an <account> tag, there are one or more <settings> tags.
+  // Each of these tags has a varying number of <setting> tags, for example:
+  //       <setting name='port' type='int'>5190</setting>
+  // Most setting names correspond to Instantbird's namings due to
+  // the use of libpurple - currently the ExistingAccounts handle
+  // any incorrect setting names passed to the set*() methods.
+  _parseSettings: function(aSettings, aExistingAccount) {
+    for (let i = 0; i < aSettings.length; ++i) {
+      let eachSetting = aSettings[i].getElementsByTagName("setting")
+      for (let j = 0; j < eachSetting.length; ++j) {
+        let setting = eachSetting[j];
+        let type = setting.getAttribute("type");
+        let name = setting.getAttribute("name");
+        if (!setting.childNodes[0])
+          continue;
+        let value = setting.childNodes[0].nodeValue;
+
+        // Filter out unused common preferences.
+        let pidginSpecificSettings = [
+          "check-mail", "use-global-buddyicon", "buddy_icon_timestamp"
+        ];
+        if (pidginSpecificSettings.indexOf(name) !== -1)
+          continue;
+
+        if (type === "bool") {
+          if (name == "auto-login")
+            aExistingAccount.autoLogin = (value == "1");
+          else
+            aExistingAccount.setBool(name, (value == "1"));
+        }
+        else if (type === "int")
+          aExistingAccount.setInt(name, parseInt(value));
+        else if (type === "string")
+          aExistingAccount.setString(name, value);
+      }
+    }
+  },
+
+  importData: function(aAccount, aPreference, aObserver) {
+    this._observer = aObserver;
+    let pref = JSON.parse(aPreference);
+
+    // If this is the initial call to start the import, files should be located.
+    if (!pref.logFiles) {
+      pref.logFiles = this._findAccountLogs(aAccount);
+      this._updateImportStatus(aAccount, JSON.stringify(pref));
+      return;
+    }
+
+    // The import is finished when no more files are pending.
+    if (!pref.logFiles.length) {
+      this._updateImportStatus(aAccount, null);
+      return;
+    }
+
+    let logFile = Cc["@mozilla.org/file/local;1"]
+                    .createInstance(Ci.nsILocalFile);
+    logFile.initWithPath(pref.logFiles[0]);
+    pref.logFiles = pref.logFiles.slice(1);
+
+    // Create a stream to read lines from the log file.
+    let logStream = Cc["@mozilla.org/network/file-input-stream;1"]
+                      .createInstance(Ci.nsIFileInputStream);
+    logStream.init(logFile, 0x1, 0, 0);
+    logStream.QueryInterface(Ci.nsILineInputStream);
+
+    let conversation, sessionDatestring, username;
+    let [line, more] = [{}, false];
+    do {
+      more = logStream.readLine(line);
+      let val = line.value;
+      if (!val)
+        continue;
+
+      if (conversation) {
+        // The log files are either HTML or TXT format. Separate parsing methods
+        // are used, as the HTML formatting reveals more information.
+        if (val[0] === "<")
+          this._parseHTMLMessage(val, conversation, sessionDatestring);
+        else
+          this._parsePlaintextMessage(val, conversation, sessionDatestring, username);
+        continue;
+      }
+
+      // Check for the conversation beginning header (in both HTML and TXT logs)
+      let convHead = /with\s(.+?)\sat\s([\d\/:\s]+[AP]?M?)\son\s(.+?)\s\((.+?)\)/;
+      let convMatches = val.match(convHead);
+      if (convMatches) {
+        let [target, date] = convMatches.slice(1);
+        let isChat = (target.indexOf("#") === 0);
+
+        // The username is preserved to determine incoming/outgoing messages.
+        username = convMatches[3];
+        if (username.indexOf("@") !== -1)
+          username = username.slice(0, username.indexOf("@"));
+
+        // TODO: Date may be either MM/DD/YYYY or DD/MM/YYYY and Date.parse
+        // does not recognize this (but the importer can by checking for AM/PM)
+        sessionDatestring = date.split(" ")[0];
+        conversation = new ImporterConversation(target, aAccount, isChat);
+        Services.logs.logConversation(conversation, new Date(date).getTime());
+      }
+    } while (more);
+
+    // EOF has been reached, the next file will be read if available.
+    logStream.close();
+    this._updateImportStatus(aAccount, JSON.stringify(pref));
+  },
+
+  // Information from the tags can be used to determine additional information
+  // on what type of message has been read.
+  _parseHTMLMessage: function(aLine, aConversation, aSessionDatestring) {
+    let msgObject = {};
+    let who, text;
+
+    let dateRegex = />\(([\d\/:\s]+[AP]?M?)\)<\/font>/;
+    let matches = aLine.match(dateRegex);
+    if (matches) {
+      let msgDate = this._createMessageDate(matches[1], aSessionDatestring);
+      msgObject.time = (msgDate / 1000);
+    }
+
+    let messageRegex = /<b>(.+):<\/b><\/font>\s(.+)<br\/>/;
+    let systemRegex = /<b>\s(.+)<\/b><br\/>/;
+
+    // Outgoing message usernames are colored #16569E, incoming are #A82F2F.
+    if (aLine.indexOf("<font color=\"#16569E\">") === 0) {
+      [who, text] = aLine.match(messageRegex).slice(1);
+      msgObject.outgoing = true;
+    }
+    else if (aLine.indexOf("<font color=\"#A82F2F\">") === 0) {
+      // Some incoming messages have a body tag enclosing them.
+      let bodyRegex = /<b>(.+):<\/b><\/font>\s<body>(.+)<\/body><br\/>/;
+      if (bodyRegex.test(aLine))
+        [who, text] = aLine.match(bodyRegex).slice(1);
+      else
+        [who, text] = aLine.match(messageRegex).slice(1);
+      msgObject.incoming = true;
+    }
+    else if (aLine.indexOf("<font size=\"2\">") === 0) {
+      // This is a system message of some sort.
+      if (systemRegex.test(aLine))
+        text = aLine.match(systemRegex)[1];
+      msgObject.system = true;
+    }
+
+    if (text)
+      aConversation.writeMessage(who, text, msgObject);
+    else
+      dump("\nUnknown Pidgin log message: " + aLine);
+    return;
+  },
+
+  _parsePlaintextMessage: function(aLine, aConversation, aSessionDatestring, aUser) {
+    let msgObject = {};
+    let who, text;
+
+    let dateRegex = /^\(([\d\/:\s]+[AP]?M?)\)/;
+    let matches = aLine.match(dateRegex);
+    if (matches) {
+      let msgDate = this._createMessageDate(matches[1], aSessionDatestring);
+      msgObject.time = (msgDate / 1000);
+    }
+
+    // TODO: These are broad matching expressions to simply determine between
+    // a regular message and a system message. A further step might be reading
+    // the localizations of Pidgin and creating a regex from there.
+    let messageRegex = /\)\s(\S+?):\s(.+)/;
+    let systemRegex = /\)\s(.+)/;
+
+    if (messageRegex.test(aLine)) {
+      [who, text] = aLine.match(messageRegex).slice(1);
+      msgObject.outgoing = (aUser === who);
+      msgObject.incoming = !msgObject.outgoing;
+    }
+    else if (systemRegex.test(aLine)) {
+      text = aLine.match(systemRegex)[1];
+      msgObject.system = true;
+    }
+
+    if (text)
+      aConversation.writeMessage(who, text, msgObject);
+    else
+      dump("\nUnknown Pidgin log message: " + aLine);
+    return;
+  },
+
+  _createMessageDate: function(aDatestring, aSessionDatestring) {
+    // TODO: Account for chats spanning more than one day?
+    let fullDate = aSessionDatestring + " " + aDatestring;
+    return (new Date(fullDate));
+  },
+
+  // The chat file/folder structure is nearly the same as the one used by the
+  // chat/ logger. The log files are either HTML or TXT, not JSON.
+  _findAccountLogs: function(aAccount) {
+    let logDir = this._getPurpleDirectory();
+    logDir.append("logs");
+    if (!logDir.exists())
+      return [];
+    logDir.append(aAccount.protocol.normalizedName);
+    if (!logDir.exists())
+      return [];
+    logDir.append(aAccount.normalizedName);
+    if (!logDir.exists())
+      return [];
+
+    let foundLogFiles = [];
+    // Each folder within this account's folder holds chats and conversations.
+    let logFolders = logDir.directoryEntries;
+    while (logFolders.hasMoreElements()) {
+      let logFolder = logFolders.getNext().QueryInterface(Ci.nsIFile);
+      // The .system folder has account status logs and should not be imported.
+      if (logFolder.leafName == ".system")
+        continue;
+      let logFiles = logFolder.directoryEntries;
+      while (logFiles.hasMoreElements()) {
+        let logFile = logFiles.getNext().QueryInterface(Ci.nsIFile);
+        foundLogFiles.push(logFile.path);
+      }
+    }
+    return foundLogFiles;
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{5063dfc7-1e04-42c1-be9f-8480f42ffd65}")
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([pidginImporter]);
diff --git a/chat/importers/pidgin.manifest b/chat/importers/pidgin.manifest
new file mode 100644
--- /dev/null
+++ b/chat/importers/pidgin.manifest
@@ -0,0 +1,3 @@
+component {5063dfc7-1e04-42c1-be9f-8480f42ffd65} pidgin.js
+contract @mozilla.org/chat/pidginimporter;1 {5063dfc7-1e04-42c1-be9f-8480f42ffd65}
+category im-import-plugin importer-pidgin @mozilla.org/chat/pidginimporter;1
diff --git a/chat/importers/test/importerTestHelper.jsm b/chat/importers/test/importerTestHelper.jsm
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/importerTestHelper.jsm
@@ -0,0 +1,50 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const EXPORTED_SYMBOLS = ["importerTestHelper"];
+
+const {classes: Cc, interfaces: Ci} = Components;
+
+// This helper provides commonly needed methods to the importer XPCShell tests.
+const importerTestHelper = {
+  // Create a unique instance of an importer.
+  getImporterJSInstance: function(aImporterName) {
+    let cid;
+    let importerName = aImporterName.toLowerCase();
+    if (importerName === "googletalk")
+      cid = "@mozilla.org/chat/googletalkimporter;1"
+    else if (importerName === "mirc")
+      cid = "@mozilla.org/chat/mircimporter;1";
+    else if (importerName === "pidgin")
+      cid = "@mozilla.org/chat/pidginimporter;1";
+    else if (importerName === "xchat")
+      cid = "@mozilla.org/chat/xchatimporter;1";
+    else {
+      dump("importerTestHelper must be updated to support this ID!");
+      return null;
+    }
+    return Cc[cid].createInstance().wrappedJSObject;
+  },
+
+  // Create a unique temporary directory for writing some test files.
+  createTempDirectory: function() {
+    let tempDir = Services.dirsvc.get("TmpD", Ci.nsIFile);
+    tempDir.append("ixpctesttmp");
+    tempDir.createUnique(Ci.nsIFile.DIRECTORY_TYPE, 0666);
+    return tempDir.clone();
+  },
+
+  // Synchronously write a file to a specified directory.
+  writeTestFile: function(aFilename, aStringContents, aDirectory) {
+    let tempFile = aDirectory.clone();
+    tempFile.append(aFilename);
+
+    // A synchronous write, see
+    // https://developer.mozilla.org/en/Code_snippets/File_I//O#Writing_a_File
+    let foStream = Cc["@mozilla.org/network/file-output-stream;1"]
+                     .createInstance(Ci.nsIFileOutputStream);
+    foStream.init(tempFile, 0x02 | 0x08 | 0x20, 0666, 0);
+    foStream.write(aStringContents, aStringContents.length);
+    foStream.close();
+  }
+};
diff --git a/chat/importers/test/test_aim_Blowfish.js b/chat/importers/test/test_aim_Blowfish.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/test_aim_Blowfish.js
@@ -0,0 +1,165 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Components.utils.import("resource:///modules/blowfish.jsm");
+
+// These tests verify the Blowfish cipher used by the client importers.
+function run_test() {
+  add_test(test_ECBEncryption);
+  add_test(test_ECBDecryption);
+  run_next_test();
+}
+
+// The following are the popular Blowfish test vectors by Eric Young.
+// http://www.schneier.com/code/vectors.txt
+const VECTOR_KEYS = [
+  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
+  [0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11],
+  [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
+  [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11],
+  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10],
+  [0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 0x57],
+  [0x01, 0x31, 0xD9, 0x61, 0x9D, 0xC1, 0x37, 0x6E],
+  [0x07, 0xA1, 0x13, 0x3E, 0x4A, 0x0B, 0x26, 0x86],
+  [0x38, 0x49, 0x67, 0x4C, 0x26, 0x02, 0x31, 0x9E],
+  [0x04, 0xB9, 0x15, 0xBA, 0x43, 0xFE, 0xB5, 0xB6],
+  [0x01, 0x13, 0xB9, 0x70, 0xFD, 0x34, 0xF2, 0xCE],
+  [0x01, 0x70, 0xF1, 0x75, 0x46, 0x8F, 0xB5, 0xE6],
+  [0x43, 0x29, 0x7F, 0xAD, 0x38, 0xE3, 0x73, 0xFE],
+  [0x07, 0xA7, 0x13, 0x70, 0x45, 0xDA, 0x2A, 0x16],
+  [0x04, 0x68, 0x91, 0x04, 0xC2, 0xFD, 0x3B, 0x2F],
+  [0x37, 0xD0, 0x6B, 0xB5, 0x16, 0xCB, 0x75, 0x46],
+  [0x1F, 0x08, 0x26, 0x0D, 0x1A, 0xC2, 0x46, 0x5E],
+  [0x58, 0x40, 0x23, 0x64, 0x1A, 0xBA, 0x61, 0x76],
+  [0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xB0, 0x07],
+  [0x49, 0x79, 0x3E, 0xBC, 0x79, 0xB3, 0x25, 0x8F],
+  [0x4F, 0xB0, 0x5E, 0x15, 0x15, 0xAB, 0x73, 0xA7],
+  [0x49, 0xE9, 0x5D, 0x6D, 0x4C, 0xA2, 0x29, 0xBF],
+  [0x01, 0x83, 0x10, 0xDC, 0x40, 0x9B, 0x26, 0xD6],
+  [0x1C, 0x58, 0x7F, 0x1C, 0x13, 0x92, 0x4F, 0xEF],
+  [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01],
+  [0x1F, 0x1F, 0x1F, 0x1F, 0x0E, 0x0E, 0x0E, 0x0E],
+  [0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1, 0xFE],
+  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
+  [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
+  [0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10]
+];
+
+const VECTOR_PLAINTEXT = [
+  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
+  [0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01],
+  [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11],
+  [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11],
+  [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
+  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
+  [0x01, 0xA1, 0xD6, 0xD0, 0x39, 0x77, 0x67, 0x42],
+  [0x5C, 0xD5, 0x4C, 0xA8, 0x3D, 0xEF, 0x57, 0xDA],
+  [0x02, 0x48, 0xD4, 0x38, 0x06, 0xF6, 0x71, 0x72],
+  [0x51, 0x45, 0x4B, 0x58, 0x2D, 0xDF, 0x44, 0x0A],
+  [0x42, 0xFD, 0x44, 0x30, 0x59, 0x57, 0x7F, 0xA2],
+  [0x05, 0x9B, 0x5E, 0x08, 0x51, 0xCF, 0x14, 0x3A],
+  [0x07, 0x56, 0xD8, 0xE0, 0x77, 0x47, 0x61, 0xD2],
+  [0x76, 0x25, 0x14, 0xB8, 0x29, 0xBF, 0x48, 0x6A],
+  [0x3B, 0xDD, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02],
+  [0x26, 0x95, 0x5F, 0x68, 0x35, 0xAF, 0x60, 0x9A],
+  [0x16, 0x4D, 0x5E, 0x40, 0x4F, 0x27, 0x52, 0x32],
+  [0x6B, 0x05, 0x6E, 0x18, 0x75, 0x9F, 0x5C, 0xCA],
+  [0x00, 0x4B, 0xD6, 0xEF, 0x09, 0x17, 0x60, 0x62],
+  [0x48, 0x0D, 0x39, 0x00, 0x6E, 0xE7, 0x62, 0xF2],
+  [0x43, 0x75, 0x40, 0xC8, 0x69, 0x8F, 0x3C, 0xFA],
+  [0x07, 0x2D, 0x43, 0xA0, 0x77, 0x07, 0x52, 0x92],
+  [0x02, 0xFE, 0x55, 0x77, 0x81, 0x17, 0xF1, 0x2A],
+  [0x1D, 0x9D, 0x5C, 0x50, 0x18, 0xF7, 0x28, 0xC2],
+  [0x30, 0x55, 0x32, 0x28, 0x6D, 0x6F, 0x29, 0x5A],
+  [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
+  [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
+  [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF],
+  [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
+  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
+  [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
+];
+
+const VECTOR_CIPHERTEXT = [
+  [0x4E, 0xF9, 0x97, 0x45, 0x61, 0x98, 0xDD, 0x78],
+  [0x51, 0x86, 0x6F, 0xD5, 0xB8, 0x5E, 0xCB, 0x8A],
+  [0x7D, 0x85, 0x6F, 0x9A, 0x61, 0x30, 0x63, 0xF2],
+  [0x24, 0x66, 0xDD, 0x87, 0x8B, 0x96, 0x3C, 0x9D],
+  [0x61, 0xF9, 0xC3, 0x80, 0x22, 0x81, 0xB0, 0x96],
+  [0x7D, 0x0C, 0xC6, 0x30, 0xAF, 0xDA, 0x1E, 0xC7],
+  [0x4E, 0xF9, 0x97, 0x45, 0x61, 0x98, 0xDD, 0x78],
+  [0x0A, 0xCE, 0xAB, 0x0F, 0xC6, 0xA0, 0xA2, 0x8D],
+  [0x59, 0xC6, 0x82, 0x45, 0xEB, 0x05, 0x28, 0x2B],
+  [0xB1, 0xB8, 0xCC, 0x0B, 0x25, 0x0F, 0x09, 0xA0],
+  [0x17, 0x30, 0xE5, 0x77, 0x8B, 0xEA, 0x1D, 0xA4],
+  [0xA2, 0x5E, 0x78, 0x56, 0xCF, 0x26, 0x51, 0xEB],
+  [0x35, 0x38, 0x82, 0xB1, 0x09, 0xCE, 0x8F, 0x1A],
+  [0x48, 0xF4, 0xD0, 0x88, 0x4C, 0x37, 0x99, 0x18],
+  [0x43, 0x21, 0x93, 0xB7, 0x89, 0x51, 0xFC, 0x98],
+  [0x13, 0xF0, 0x41, 0x54, 0xD6, 0x9D, 0x1A, 0xE5],
+  [0x2E, 0xED, 0xDA, 0x93, 0xFF, 0xD3, 0x9C, 0x79],
+  [0xD8, 0x87, 0xE0, 0x39, 0x3C, 0x2D, 0xA6, 0xE3],
+  [0x5F, 0x99, 0xD0, 0x4F, 0x5B, 0x16, 0x39, 0x69],
+  [0x4A, 0x05, 0x7A, 0x3B, 0x24, 0xD3, 0x97, 0x7B],
+  [0x45, 0x20, 0x31, 0xC1, 0xE4, 0xFA, 0xDA, 0x8E],
+  [0x75, 0x55, 0xAE, 0x39, 0xF5, 0x9B, 0x87, 0xBD],
+  [0x53, 0xC5, 0x5F, 0x9C, 0xB4, 0x9F, 0xC0, 0x19],
+  [0x7A, 0x8E, 0x7B, 0xFA, 0x93, 0x7E, 0x89, 0xA3],
+  [0xCF, 0x9C, 0x5D, 0x7A, 0x49, 0x86, 0xAD, 0xB5],
+  [0xD1, 0xAB, 0xB2, 0x90, 0x65, 0x8B, 0xC7, 0x78],
+  [0x55, 0xCB, 0x37, 0x74, 0xD1, 0x3E, 0xF2, 0x01],
+  [0xFA, 0x34, 0xEC, 0x48, 0x47, 0xB2, 0x68, 0xB2],
+  [0xA7, 0x90, 0x79, 0x51, 0x08, 0xEA, 0x3C, 0xAE],
+  [0xC3, 0x9E, 0x07, 0x2D, 0x9F, 0xAC, 0x63, 0x1D],
+  [0x01, 0x49, 0x33, 0xE0, 0xCD, 0xAF, 0xF6, 0xE4],
+  [0xF2, 0x1E, 0x9A, 0x77, 0xB7, 0x1C, 0x49, 0xBC],
+  [0x24, 0x59, 0x46, 0x88, 0x57, 0x54, 0x36, 0x9A],
+  [0x6B, 0x5C, 0x5A, 0x9C, 0x5D, 0x9E, 0x0A, 0x5A]
+];
+
+// This test checks the Blowfish cipher ability to produce valid results from
+// test encryptions using known test vectors.
+function test_ECBEncryption() {
+  for (let i = 0; i < VECTOR_KEYS.length; ++i) {
+    let key = Uint8Array(VECTOR_KEYS[i]);
+    let cleartext = Uint8Array(VECTOR_PLAINTEXT[i]);
+
+    let blowfish = new Blowfish(key);
+    let result = blowfish.encrypt(cleartext);
+
+    // Check that the test vector bytes are equal to the encrypted plaintext
+    // bytes produced above.
+    for (let j = 0; j < VECTOR_CIPHERTEXT[i].length; ++j) {
+      do_check_eq(VECTOR_CIPHERTEXT[i][j], result[j]);
+    }
+  }
+
+  run_next_test();
+}
+
+// This test checks the Blowfish cipher ability to produce valid results from
+// test decryptions using known test vectors.
+function test_ECBDecryption() {
+  for (let i = 0; i < VECTOR_KEYS.length; ++i) {
+    let key = Uint8Array(VECTOR_KEYS[i]);
+    let ciphertext = Uint8Array(VECTOR_CIPHERTEXT[i]);
+
+    let blowfish = new Blowfish(key);
+    let result = blowfish.decrypt(ciphertext);
+
+    // Check that the test vector bytes are equal to the decrypted ciphertext
+    // bytes produced above.
+    for (let j = 0; j < VECTOR_PLAINTEXT[i].length; ++j) {
+      do_check_eq(VECTOR_PLAINTEXT[i][j], result[j]);
+    }
+  }
+
+  run_next_test();
+}
diff --git a/chat/importers/test/test_googletalk_Passwords.js b/chat/importers/test/test_googletalk_Passwords.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/test_googletalk_Passwords.js
@@ -0,0 +1,44 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Components.utils.import("resource://test/importerTestHelper.jsm");
+
+// These tests verify that the password methods used in the Google Talk
+// importer produce the correct results.
+function run_test() {
+  add_test(test_entropyInitialization);
+  run_next_test();
+}
+
+// This test checks that the GTalk importer correctly creates the entropy data
+// necessary for decrypting and decoding the user's password.
+function test_entropyInitialization() {
+  const USERNAME_DOMAIN_PAIRS = [
+    {user: "User", domain: "Domain"},
+    {user: "Alph4Num3r1c", domain: "Us3r-PC"},
+    {user: "Sp ace.Dot", domain: "Dot.domain"}
+  ];
+
+  const FINAL_ENTROPY = [
+    Uint32Array([0x436f14d3, 0xc6125cd9, 0xb62cc8b6, 0xab23ae8a]),
+    Uint32Array([0x23c1afa5, 0xbebef1e6, 0xa69b9a32, 0xaba71f8f]),
+    Uint32Array([0x636add, 0x3292eaed, 0xc57183ed, 0x7707e35a])
+  ];
+
+  let importer = importerTestHelper.getImporterJSInstance("googletalk");
+  for (let i = 0; i < USERNAME_DOMAIN_PAIRS.length; ++i) {
+    // Overwrite the User/Domain retrieval methods.
+    importer._getCurrentUser = function() { return USERNAME_DOMAIN_PAIRS[i].user; };
+    importer._getCurrentDomain = function() { return USERNAME_DOMAIN_PAIRS[i].domain; };
+
+    // The entropy will be a Uint32Array of length 4.
+    let entropy = importer._initializeEntropy();
+
+    // Verify the predicted entropy against the produced.
+    for (let j = 0; j < 4; ++j) {
+      do_check_eq(FINAL_ENTROPY[i][j], entropy[j]);
+    }
+  }
+  run_next_test();
+}
diff --git a/chat/importers/test/test_mIRC_ServerString.js b/chat/importers/test/test_mIRC_ServerString.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/test_mIRC_ServerString.js
@@ -0,0 +1,42 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Components.utils.import("resource://test/importerTestHelper.jsm");
+
+// These tests check the mIRC importer's ability to correctly parse the
+// unusual string format of the server preference.
+function run_test() {
+  add_test(test_variousValidServers);
+  run_next_test();
+}
+
+// This test checks the correct parsing of various server strings
+// created in the mirc.ini configuration file.
+function test_variousValidServers() {
+  const MIRC_SERVER_PORT_STRINGS = [
+    "Random serverSERVER:irc.mozilla.org:6667GROUP:Mozilla",
+    "Random serverSERVER:chat.freenode.net:6666GROUP:Freenode",
+    "CA, ON, TorontoSERVER:irc.teksavvy.ca:6663GROUP:EFnet",
+    "US, VA, RichmondSERVER:punch.va.us.dal.net:6668GROUP:DALnet"
+  ];
+
+  // These are the expected results after parsing the host, port, and group
+  // from the above strings.
+  const MIRC_SERVERS = [
+    "irc.mozilla.org", "chat.freenode.net",
+    "irc.teksavvy.ca", "punch.va.us.dal.net"
+  ];
+  const MIRC_PORTS = [ 6667, 6666, 6663, 6668 ];
+  const MIRC_GROUPS = ["Mozilla", "Freenode", "EFnet", "DALnet"];
+
+  let importer = importerTestHelper.getImporterJSInstance("mirc");
+  for (let i = 0; i < MIRC_SERVER_PORT_STRINGS.length; ++i) {
+    let servInfo = importer._parseServerString(MIRC_SERVER_PORT_STRINGS[i]);
+
+    do_check_eq(servInfo.host, MIRC_SERVERS[i]);
+    do_check_eq(servInfo.port, MIRC_PORTS[i]);
+    do_check_eq(servInfo.group, MIRC_GROUPS[i]);
+  }
+  run_next_test();
+}
diff --git a/chat/importers/test/test_mIRC_findAccounts.js b/chat/importers/test/test_mIRC_findAccounts.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/test_mIRC_findAccounts.js
@@ -0,0 +1,208 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://test/importerTestHelper.jsm");
+
+var XULAppInfo = {
+  vendor: "Mozilla",
+  name: "XPCShell",
+  ID: "{39885e5f-f6b4-4e2a-87e5-6259ecf79011}",
+  version: "5",
+  appBuildID: "2007010101",
+  platformVersion: "1.9",
+  platformBuildID: "2007010101",
+  inSafeMode: false,
+  logConsoleErrors: true,
+  OS: "WINNT", // mIRC requires a Windows OS.
+  XPCOMABI: "noarch-spidermonkey",
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIXULAppInfo, Ci.nsIXULRuntime,
+                                         Ci.nsISupports])
+};
+
+var XULAppInfoFactory = {
+  createInstance: function (outer, iid) {
+    if (outer != null)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+    return XULAppInfo.QueryInterface(iid);
+  }
+};
+
+// These tests check the mIRC importer findAccounts() procedure to ensure
+// correct account detection and proper exit signaling.
+//
+// Test 1: Checks if the mIRC importer gracefully exits when no files are present.
+// Test 2: Checks if the mIRC importer can handle an empty config file.
+// Test 3: Tests the mIRC importer with a typical configuration.
+function run_test() {
+  // Having an implementation of nsIXULAppInfo is required for Services.jsm
+  Components.manager.QueryInterface(Ci.nsIComponentRegistrar)
+            .registerFactory(Components.ID("{48a4e946-1f9f-4224-b4b0-9a54183cb81e}"),
+                             "XULAppInfo", "@mozilla.org/xre/app-info;1",
+                             XULAppInfoFactory);
+
+  // The core is needed for the mIRC importer to set ExistingAccount settings.
+  do_get_profile();
+  let core = Cc["@mozilla.org/chat/core-service;1"]
+               .getService(Ci.imICoreService);
+  core.init();
+  do_register_cleanup(function() { core.quit(); }.bind(this));
+
+  // If one or more of the tests fail, the xpcshell testing will stall
+  // indefinitely without this. 5 seconds is plenty of time for the tests
+  // to complete.
+  do_timeout(5000, function() {
+    do_throw("A mIRC importer test has not signaled completion!");
+  });
+
+  add_test(test_noMircFilesPresent);
+  add_test(test_emptyMircINI);
+  add_test(test_typicalAccount);
+  run_next_test();
+}
+
+// It is important that an importer works when no files are present! The test
+// should be notified of "account-search-finished" to properly finish.
+function test_noMircFilesPresent() {
+  let importer = importerTestHelper.getImporterJSInstance("mirc");
+
+  // The current working directory will not have any mIRC files, making
+  // it a simple choice to use for testing this case.
+  importer._getMircDirectory = function() do_get_cwd().clone();
+
+  // This test will succeed if the specially-crafted observer below receives
+  // the "account-search-finished" notification.
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_throw("test_noMircFilesPresent: \"existing-account-found\" called!");
+          break;
+        case "account-search-finished":
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  importer.findAccounts(observer);
+}
+
+// If the mirc.ini file is empty, the importer should not encounter issues
+// and properly signal that it is finished.
+function test_emptyMircINI() {
+  // The test mirc.ini file will be the single space, " ".
+  const MIRC_INI_EMPTY = " ";
+
+  // A new directory will be created in the user's Temp folder.
+  let newMircDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("mirc.ini", MIRC_INI_EMPTY, newMircDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("mirc");
+  importer._getMircDirectory = function() newMircDir.clone();
+
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_throw("test_emptyMircINI: \"existing-account-found\" called!");
+          break;
+        case "account-search-finished":
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory (and dummy mirc.ini) after
+  // the test finishes.
+  do_register_cleanup(function() { newMircDir.remove(true); }.bind(this));
+
+  importer.findAccounts(observer);
+}
+
+// This test verifies that the mIRC importer can find the configured IRC
+// account and associated settings from a basic mirc.ini file.
+function test_typicalAccount() {
+  // The test mirc.ini file will have all of the settings the importer
+  // should recognize.
+  const MIRC_INI_TYPICAL =
+      // The [mirc] section has 'nick' and 'host' keys which are necessary
+      // for an account to be created. There are also 'user', 'email', and
+      // 'anick' keys that are ignored.
+      "[mirc]\r\n"
+    + "nick=Testnick\r\n"
+    + "host=Some test serverSERVER:irc.testnet.org:1234GROUP:Testnet"
+    + "\r\n\r\n"
+      // The [options] section has several lines of numerical preferences,
+      // split by commas. Refer to the documentation links in mIRC.js for
+      // more information; the only one of concern is the first 0/1 boolean
+      // of n0, which specifies whether to auto-connect the account.
+    + "[options]\r\n"
+    + "n0=1,1,0,1,0,0,300,0,0,0,1,0,0,0,0,0,1,0,0"
+    + "\r\n\r\n"
+      // The [text] section contains one key of interest, the user specified
+      // quit message.
+    + "[text]\r\n"
+    + "quit=I am leaving now!\r\n";
+
+  // A new directory will be created in the user's Temp folder.
+  let newMircDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("mirc.ini", MIRC_INI_TYPICAL, newMircDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("mirc");
+  importer._getMircDirectory = function() newMircDir.clone();
+
+  // The observer checks that the account described above was successfully
+  // parsed by checking values of an ExistingAccount.
+  let observer = {
+    accountObserved: false,
+    settingCount: 0,
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_check_eq(aSubject.name, "Testnick@irc.testnet.org");
+          do_check_eq(aSubject.protocolId, "prpl-irc");
+          do_check_true(aSubject.autoLogin);
+
+          // Only the non-default PrplPrefs should be present.
+          let settings = aSubject.getOptions();
+          while (settings.hasMoreElements()) {
+            let setting = settings.getNext().QueryInterface(Ci.prplIPref);
+            switch (setting.type) {
+              case Ci.prplIPref["typeBool"]:
+                do_throw("test_typicalAccount: Boolean pref found but none were set!");
+                break;
+              case Ci.prplIPref["typeInt"]:
+                do_check_eq(setting.name, "port");
+                do_check_eq(setting.getInt(), 1234);
+                break;
+              case Ci.prplIPref["typeString"]:
+                do_check_eq(setting.name, "quitmsg");
+                do_check_eq(setting.getString(), "I am leaving now!");
+                break;
+              case Ci.prplIPref["typeList"]:
+              default:
+                do_throw("test_typicalAccount: Bad type on ExistingAccount PrplPref");
+            }
+            this.settingCount++;
+          }
+          this.accountObserved = true;
+          break;
+        case "account-search-finished":
+          do_check_true(this.accountObserved);
+          do_check_eq(this.settingCount, 2);
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory after the test finishes.
+  do_register_cleanup(function() { newMircDir.remove(true); }.bind(this));
+
+  importer.findAccounts(observer);
+}
diff --git a/chat/importers/test/test_pidgin_findAccounts.js b/chat/importers/test/test_pidgin_findAccounts.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/test_pidgin_findAccounts.js
@@ -0,0 +1,352 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://test/importerTestHelper.jsm");
+
+var XULAppInfo = {
+  vendor: "Mozilla",
+  name: "XPCShell",
+  ID: "{39885e5f-f6b4-4e2a-87e5-6259ecf79011}",
+  version: "5",
+  appBuildID: "2007010101",
+  platformVersion: "1.9",
+  platformBuildID: "2007010101",
+  inSafeMode: false,
+  logConsoleErrors: true,
+  OS: "XPCShell",
+  XPCOMABI: "noarch-spidermonkey",
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIXULAppInfo, Ci.nsIXULRuntime,
+                                         Ci.nsISupports])
+};
+
+var XULAppInfoFactory = {
+  createInstance: function (outer, iid) {
+    if (outer != null)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+    return XULAppInfo.QueryInterface(iid);
+  }
+};
+
+// These tests check the Pidgin importer findAccounts() procedure to ensure
+// correct account detection and proper exit signaling.
+//
+// Test 1: Checks that the importer exits properly with no files present.
+// Test 2: Tests when Pidgin's "accounts.xml" exists but is empty.
+// Test 3: Tests that unknown protocol accounts are not created.
+// Test 4: Checks that the importer handles common name/protocol replacements.
+// Test 5: Ensures a typical account is read properly.
+function run_test() {
+  // Having an implementation of nsIXULAppInfo is required for Services.jsm
+  Components.manager.QueryInterface(Ci.nsIComponentRegistrar)
+            .registerFactory(Components.ID("{48a4e946-1f9f-4224-b4b0-9a54183cb81e}"),
+                             "XULAppInfo", "@mozilla.org/xre/app-info;1",
+                             XULAppInfoFactory);
+
+  // The core is needed for the Pidgin importer to check prpl-id validity.
+  do_get_profile();
+  let core = Cc["@mozilla.org/chat/core-service;1"]
+               .getService(Ci.imICoreService);
+  core.init();
+  do_register_cleanup(function() { core.quit(); }.bind(this));
+
+  // If one or more of the tests fail, the xpcshell testing will stall
+  // indefinitely without this. 5 seconds is plenty of time for the tests
+  // to complete.
+  do_timeout(5000, function() {
+    do_throw("A Pidgin importer test has not signaled completion!");
+  });
+
+  add_test(test_noPurpleFilesPresent);
+  add_test(test_emptyAccountXML);
+  add_test(test_unsupportedProtocol);
+  add_test(test_nameProtocolModifications);
+  add_test(test_typicalAccount);
+  run_next_test();
+}
+
+// It is important that an importer works when no files are present! The test
+// should be notified of "account-search-finished" to properly finish.
+function test_noPurpleFilesPresent() {
+  let importer = importerTestHelper.getImporterJSInstance("pidgin");
+
+  // The current working directory will not have any .purple/ files, making
+  // it a simple choice to use for testing this case.
+  importer._getPurpleDirectory = function() do_get_cwd().clone();
+
+  // This test will succeed if the specially-crafted observer below receives
+  // the "account-search-finished" notification.
+  let observer = {observe: function(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "existing-account-found":
+        do_throw("test_noPurpleFilesPresent: \"existing-account-found\" called!");
+        break;
+      case "account-search-finished":
+        run_next_test();
+        break;
+    }
+  }};
+
+  importer.findAccounts(observer);
+}
+
+// If the accounts.xml file is empty, the importer should not encounter issues
+// and properly signal that it is finished.
+function test_emptyAccountXML() {
+  // The test accounts.xml file in this test will be the single space, " ".
+  const ACCOUNT_XML_EMPTY = " ";
+
+  // A new directory will be created in the user's Temp folder.
+  let newPurpleDir = importerTestHelper.createTempDirectory();
+
+  importerTestHelper.writeTestFile("accounts.xml", ACCOUNT_XML_EMPTY, newPurpleDir);
+  let importer = importerTestHelper.getImporterJSInstance("pidgin");
+  importer._getPurpleDirectory = function() newPurpleDir.clone();
+
+  let observer = {observe: function(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "existing-account-found":
+        do_throw("test_emptyAccountXML: \"existing-account-found\" called!");
+        break;
+      case "account-search-finished":
+        run_next_test();
+        break;
+    }
+  }};
+
+  // Remove the temporary directory (and dummy accounts.xml) after
+  // the test finishes.
+  do_register_cleanup(function() { newPurpleDir.remove(true); }.bind(this));
+
+  importer.findAccounts(observer);
+}
+
+// Pidgin supports several prpl-ids that Instantbird does not use. This test
+// checks that these are correctly ignored.
+function test_unsupportedProtocol() {
+  // The test accounts.xml file in this test will have both a valid and invalid
+  // importable account information. Instantbird supports prpl-aim but does not
+  // support prpl-faketest.
+  const ACCOUNT_XML_UNSUPPORTED = "<?xml version='1.0' encoding='UTF-8' ?>"
+    + "<account version='1.0'>"
+    + "  <account>"
+    + "    <protocol>prpl-aim</protocol>"
+    + "    <name>Supported</name>"
+    + "  </account>"
+    + "  <account>"
+    + "    <protocol>prpl-faketest</protocol>"
+    + "    <name>Unsupported</name>"
+    + "  </account>"
+    + "</account>";
+
+  let newPurpleDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("accounts.xml", ACCOUNT_XML_UNSUPPORTED, newPurpleDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("pidgin");
+  importer._getPurpleDirectory = function() newPurpleDir.clone();
+
+  // When the observer receives the accounts, two boolean properties
+  // will be toggled as needed. When the imported claims to be done,
+  // these will determine pass/fail.
+  let observer = {
+    foundsupported: false,
+    foundunsupported: false,
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          if (aSubject.name === "Supported" && aSubject.protocolId === "prpl-aim")
+            this.foundsupported = true;
+          else if (aSubject.name === "Unsupported" && aSubject.protocolId === "prpl-faketest")
+            this.foundunsupported = true;
+          else
+            do_throw("test_unsupportedProtocol: An unrecognized account was found!");
+          break;
+        case "account-search-finished":
+          do_check_true(this.foundsupported);
+          do_check_false(this.foundunsupported);
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory after the test finishes.
+  do_register_cleanup(function() { newPurpleDir.remove(true); }.bind(this));
+
+  importer.findAccounts(observer);
+}
+
+// Certain combinations of name and protocol are represented better in
+// a different form in Instantbird. This test checks whether the
+// Pidgin importer is recognizing these common forms.
+function test_nameProtocolModifications() {
+  // The test accounts.xml file in this test has both name/protocol
+  // combinations that should be changed, as well as those that should
+  // be left as-is.
+  const ACCOUNT_XML_NAMEPROTOCOLMOD = "<?xml version='1.0' encoding='UTF-8' ?>"
+    + "<account version='1.0'>"
+         // There is a prpl-facebook id that is more suitable for
+         // XMPP Facebook communications.
+    + "  <account>"
+    + "    <protocol>prpl-jabber</protocol>"
+    + "    <name>test1@chat.facebook.com/</name>"
+    + "  </account>"
+
+         // Similar to above, prpl-gtalk would suit Google accounts better.
+    + "  <account>"
+    + "    <protocol>prpl-jabber</protocol>"
+    + "    <name>test2@gmail.com/</name>"
+    + "  </account>"
+
+         // This XMPP account should simply be left alone.
+    + "  <account>"
+    + "    <protocol>prpl-jabber</protocol>"
+    + "    <name>test3@testdomain.com/</name>"
+    + "  </account>"
+    + "</account>";
+
+  let newPurpleDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("accounts.xml", ACCOUNT_XML_NAMEPROTOCOLMOD, newPurpleDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("pidgin");
+  importer._getPurpleDirectory = function() newPurpleDir.clone();
+
+  // The observer checks for the correct converted account information, and
+  // sets booleans accordingly.
+  let observer = {
+    XMPPFacebookChange: false,
+    XMPPGTalkChange: false,
+    XMPPNoChange: false,
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          if (aSubject.name === "test1" &&
+              aSubject.protocolId === "prpl-facebook") {
+            this.XMPPFacebookChange = true;
+          }
+          else if (aSubject.name === "test2@gmail.com/" &&
+                   aSubject.protocolId === "prpl-gtalk") {
+            this.XMPPGTalkChange = true;
+          }
+          else if (aSubject.name === "test3@testdomain.com/" &&
+                   aSubject.protocolId === "prpl-jabber") {
+            this.XMPPNoChange = true;
+          }
+          break;
+        case "account-search-finished":
+          do_check_true(this.XMPPFacebookChange);
+          do_check_true(this.XMPPGTalkChange);
+          do_check_true(this.XMPPNoChange);
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory after the test finishes.
+  do_register_cleanup(function() { newPurpleDir.remove(true); }.bind(this));
+
+  importer.findAccounts(observer);
+}
+
+// This test checks the overall success of the importer in finding and setting
+// the full range of supported account settings from Pidgin.
+function test_typicalAccount() {
+  // The test accounts.xml file in this test is a good example of what might be
+  // typically found in a user's .purple directory.
+  const ACCOUNT_XML_TYPICAL = "<?xml version='1.0' encoding='UTF-8' ?>"
+    + "<account version='1.0'>"
+    + "  <account>"
+    + "    <protocol>prpl-msn</protocol>"
+    + "    <name>msnUser@msn.com/</name>"
+    + "    <password>password</password>"
+    + "    <alias>msnUserAlias</alias>"
+
+           // The importer should correctly parse through potentially multiple
+           // <settings> tags per account. The settings that are relevant
+           // should be attached to the ExistingAccount - that is, settings
+           // that are usable and non-default.
+    + "    <settings>"
+    + "      <setting name='http_method' type='bool'>0</setting>"
+    + "      <setting name='endpoint-name' type='string'>Pidgin</setting>"
+    + "      <setting name='check-mail' type='bool'>0</setting>"
+    + "      <setting name='buddy_icon'/>"
+    + "      <setting name='buddy_icon_timestamp' type='int'>0</setting>"
+    + "      <setting name='http_method_server' type='string'>gateway.messenger.hotmail.com</setting>"
+    + "      <setting name='use-global-buddyicon' type='bool'>1</setting>"
+    + "      <setting name='mpop' type='bool'>0</setting>" // Non-default
+    + "      <setting name='server' type='string'>fake.hotmail.com</setting>" // Non-default
+    + "      <setting name='custom_smileys' type='bool'>1</setting>"
+    + "      <setting name='port' type='int'>9001</setting>" // Non-default
+    + "      <setting name='direct_connect' type='bool'>1</setting>"
+    + "    </settings>"
+    + "    <settings ui='gtk-gaim'>"
+             // auto-login is not stored in the same way as other settings,
+             // it has its own property in ExistingAccount.
+    + "      <setting name='auto-login' type='bool'>1</setting>"
+    + "    </settings>"
+    + "  </account>"
+    + "</account>";
+
+  let newPurpleDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("accounts.xml", ACCOUNT_XML_TYPICAL, newPurpleDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("pidgin");
+  importer._getPurpleDirectory = function() newPurpleDir.clone();
+
+  // The observer checks that the account described above was successfully
+  // parsed by checking values of an ExistingAccount.
+  let observer = {
+    accountObserved: false,
+    settingCount: 0,
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_check_eq(aSubject.name, "msnUser@msn.com/");
+          do_check_eq(aSubject.protocolId, "prpl-msn");
+          do_check_eq(aSubject.password, "password");
+          do_check_eq(aSubject.alias, "msnUserAlias");
+          do_check_true(aSubject.autoLogin);
+
+          // Only the non-default PrplPrefs should be present.
+          let settings = aSubject.getOptions();
+          while (settings.hasMoreElements()) {
+            let setting = settings.getNext().QueryInterface(Ci.prplIPref);
+            switch (setting.type) {
+              case Ci.prplIPref["typeBool"]:
+                do_check_eq(setting.name, "mpop");
+                do_check_false(setting.getBool());
+                break;
+              case Ci.prplIPref["typeInt"]:
+                do_check_eq(setting.name, "port");
+                do_check_eq(setting.getInt(), 9001);
+                break;
+              case Ci.prplIPref["typeString"]:
+                do_check_eq(setting.name, "server");
+                do_check_eq(setting.getString(), "fake.hotmail.com");
+                break;
+              case Ci.prplIPref["typeList"]:
+              default:
+                do_throw("test_typicalAccount: Bad type on ExistingAccount PrplPref");
+            }
+            this.settingCount++;
+          }
+          this.accountObserved = true;
+          break;
+        case "account-search-finished":
+          do_check_true(this.accountObserved);
+          do_check_eq(this.settingCount, 3);
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory after the test finishes.
+  do_register_cleanup(function() { newPurpleDir.remove(true); }.bind(this));
+
+  importer.findAccounts(observer);
+}
diff --git a/chat/importers/test/test_xchat_findAccounts.js b/chat/importers/test/test_xchat_findAccounts.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/test_xchat_findAccounts.js
@@ -0,0 +1,287 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://test/importerTestHelper.jsm");
+
+var XULAppInfo = {
+  vendor: "Mozilla",
+  name: "XPCShell",
+  ID: "{39885e5f-f6b4-4e2a-87e5-6259ecf79011}",
+  version: "5",
+  appBuildID: "2007010101",
+  platformVersion: "1.9",
+  platformBuildID: "2007010101",
+  inSafeMode: false,
+  logConsoleErrors: true,
+  OS: "XPCShell",
+  XPCOMABI: "noarch-spidermonkey",
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIXULAppInfo, Ci.nsIXULRuntime,
+                                         Ci.nsISupports])
+};
+
+var XULAppInfoFactory = {
+  createInstance: function (outer, iid) {
+    if (outer != null)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+    return XULAppInfo.QueryInterface(iid);
+  }
+};
+
+// These tests check the XChat importer findAccounts() procedure to ensure
+// correct account detection and proper exit signaling.
+//
+// Test 1: Checks for a proper exit when no files are found.
+// Test 2: Checks that an empty "xchat.conf" causes no problems.
+// Test 3: A similar check as above, but with an empty "servlist_.conf".
+// Test 4: Checking that an invalid server index doesn't cause problems.
+// Test 5: Tests that a regular account and settings can be found.
+function run_test() {
+  // Having an implementation of nsIXULAppInfo is required for Services.jsm
+  Components.manager.QueryInterface(Ci.nsIComponentRegistrar)
+            .registerFactory(Components.ID("{48a4e946-1f9f-4224-b4b0-9a54183cb81e}"),
+                             "XULAppInfo", "@mozilla.org/xre/app-info;1",
+                             XULAppInfoFactory);
+
+  // The core is needed to set ExistingAccount settings.
+  do_get_profile();
+  let core = Cc["@mozilla.org/chat/core-service;1"]
+               .getService(Ci.imICoreService);
+  core.init();
+  do_register_cleanup(function() { core.quit(); }.bind(this));
+
+  // If one or more of the tests fail, the xpcshell testing will stall
+  // indefinitely without this. 5 seconds is plenty of time for the tests
+  // to complete.
+  do_timeout(5000, function() {
+    do_throw("A XChat importer test has not signaled completion!");
+  });
+
+  add_test(test_noXChatFilesPresent);
+  add_test(test_emptyXChatConf);
+  add_test(test_emptyServerList);
+  add_test(test_badServerIndex);
+  add_test(test_typicalAccount);
+  run_next_test();
+}
+
+// It is important that an importer works when no files are present! The test
+// should be notified of "account-search-finished" to properly finish.
+function test_noXChatFilesPresent() {
+  let importer = importerTestHelper.getImporterJSInstance("xchat");
+
+  // The current working directory will not have any XChat files, making
+  // it a simple choice to use for testing this case.
+  importer._getXChatDirectory = function() {
+    return do_get_cwd().clone();
+  };
+
+  // This test will succeed if the specially-crafted observer below receives
+  // the "account-search-finished" notification.
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_throw("test_noXchatFilesPresent: \"existing-account-found\" called!");
+          break;
+        case "account-search-finished":
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  importer.findAccounts(observer);
+}
+
+// If the xchat.conf file is empty, the importer should not encounter issues
+// and properly signal that it is finished.
+function test_emptyXChatConf() {
+  // The test xchat.conf file will be the single space, " ".
+  const XCHAT_CONF_EMPTY = " ";
+
+  // A new directory will be created in the user's Temp folder.
+  let newXChatDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("xchat.conf", XCHAT_CONF_EMPTY, newXChatDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("xchat");
+  importer._getXChatDirectory = function() newXChatDir.clone();
+
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_throw("test_emptyXChatConf: \"existing-account-found\" called!");
+          break;
+        case "account-search-finished":
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory (and dummy xchat.conf) after
+  // the test finishes.
+  do_register_cleanup(function() { try {newXChatDir.remove(true); } catch(e) {} }.bind(this));
+
+  importer.findAccounts(observer);
+}
+
+// If the servlist_.conf file is empty, the importer will be unable to
+// find the specified server and should properly exit.
+function test_emptyServerList() {
+  // The test xchat.conf file in this case is not the source of error.
+  const XCHAT_CONF_SERVERLIST =
+    "version = 2.8.9\n" +
+    "irc_nick1 = Nick1\n" +
+    "gui_slist_select = 5\n";
+
+  // The test servlist_.conf is empty in this test.
+  const SERVLIST_EMPTY = " "
+
+  let newXChatDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("xchat.conf", XCHAT_CONF_SERVERLIST, newXChatDir);
+  importerTestHelper.writeTestFile("servlist_.conf", SERVLIST_EMPTY, newXChatDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("xchat");
+  importer._getXChatDirectory = function() newXChatDir.clone();
+
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_throw("test_emptyServerList: \"existing-account-found\" called!");
+          break;
+        case "account-search-finished":
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory after the test finishes.
+  do_register_cleanup(function() { try {newXChatDir.remove(true); } catch(e) {} }.bind(this));
+
+  importer.findAccounts(observer);
+}
+
+const SERVLIST_SMALL = "v=2.8.9\n\n"
+  + "N=Test2net\n"
+  + "E=IRC (Latin/Unicode Hybrid)\n"
+  + "F=19\n"
+  + "D=0\n"
+  + "S=irc.test2.net\n\n"
+  + "N=MoreTest\n"
+  + "E=IRC (Latin/Unicode Hybrid)\n"
+  + "F=19\n"
+  + "D=0\n"
+  + "S=irc.7-tests.org\n\n"
+  + "N=AccessTEST\n"
+  + "E=IRC (Latin/Unicode Hybrid)\n"
+  + "F=19\n"
+  + "D=0\n"
+  + "S=irc.accesstest.net\n"
+  + "S=eu.accesstest.net\n";
+
+// The xchat.conf file could request an invalid server index from an otherwise
+// valid servlist_.conf
+function test_badServerIndex() {
+  // The test xchat.conf file in this case is not the source of error.
+  const XCHAT_CONF_BADINDEX =
+    "version = 2.8.9\n" +
+    "irc_nick1 = Nick1\n" +
+    "gui_slist_select = 10\n";
+
+  let newXChatDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("xchat.conf", XCHAT_CONF_BADINDEX, newXChatDir);
+  importerTestHelper.writeTestFile("servlist_.conf", SERVLIST_SMALL, newXChatDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("xchat");
+  importer._getXChatDirectory = function() newXChatDir.clone();
+
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_throw("test_badServerIndex: \"existing-account-found\" called!");
+          break;
+        case "account-search-finished":
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory after the test finishes.
+  do_register_cleanup(function() { try {newXChatDir.remove(true); } catch(e) {} }.bind(this));
+
+  importer.findAccounts(observer);
+}
+
+// This is a basic test of the XChat importer's ability to read the configured
+// IRC account and associated settings.
+function test_typicalAccount() {
+  // The test xchat.conf file in this case is not the source of error.
+  const XCHAT_CONF_NORMAL =
+    "version = 2.8.9\n" +
+    "irc_nick1 = Nick1\n" +
+    "gui_slist_select = 1\n" +
+    "irc_part_reason = Parting to test\n" +
+    "irc_quit_reason = Quiting to get some sleep\n";
+
+  let newXChatDir = importerTestHelper.createTempDirectory();
+  importerTestHelper.writeTestFile("xchat.conf", XCHAT_CONF_NORMAL, newXChatDir);
+  importerTestHelper.writeTestFile("servlist_.conf", SERVLIST_SMALL, newXChatDir);
+
+  let importer = importerTestHelper.getImporterJSInstance("xchat");
+  importer._getXChatDirectory = function() newXChatDir.clone();
+
+  let observer = {
+    accountObserved: false,
+    settingCount: 0,
+    observe: function(aSubject, aTopic, aData) {
+      switch (aTopic) {
+        case "existing-account-found":
+          do_check_eq(aSubject.name, "Nick1@irc.7-tests.org");
+          do_check_eq(aSubject.protocolId, "prpl-irc");
+
+          // Only the non-default PrplPrefs should be present.
+          let settings = aSubject.getOptions();
+          while (settings.hasMoreElements()) {
+            let setting = settings.getNext().QueryInterface(Ci.prplIPref);
+            switch (setting.type) {
+              case Ci.prplIPref["typeString"]:
+                if (setting.name === "partmsg")
+                  do_check_eq(setting.getString(), "Parting to test");
+                else if (setting.name === "quitmsg")
+                  do_check_eq(setting.getString(), "Quiting to get some sleep");
+                else
+                  do_throw("test_typicalAccount: Invalid string preference!");
+                break;
+              case Ci.prplIPref["typeBool"]:
+              case Ci.prplIPref["typeInt"]:
+              case Ci.prplIPref["typeList"]:
+              default:
+                do_throw("test_typicalAccount: Bad type on ExistingAccount PrplPref");
+            }
+            this.settingCount++;
+          }
+          this.accountObserved = true;
+          break;
+        case "account-search-finished":
+          do_check_true(this.accountObserved);
+          do_check_eq(this.settingCount, 2);
+          run_next_test();
+          break;
+      }
+    }
+  };
+
+  // Remove the temporary directory after the test finishes.
+  do_register_cleanup(function() { try {newXChatDir.remove(true); } catch(e) {} }.bind(this));
+
+  importer.findAccounts(observer);
+}
diff --git a/chat/importers/test/xpcshell.ini b/chat/importers/test/xpcshell.ini
new file mode 100644
--- /dev/null
+++ b/chat/importers/test/xpcshell.ini
@@ -0,0 +1,15 @@
+[DEFAULT]
+head =
+tail =
+
+[test_aim_Blowfish.js]
+
+[test_googletalk_Passwords.js]
+
+[test_mIRC_ServerString.js]
+[test_mIRC_findAccounts.js]
+run-if = os == 'win'
+
+[test_pidgin_findAccounts.js]
+
+[test_xchat_findAccounts.js]
diff --git a/chat/importers/wlm.js b/chat/importers/wlm.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/wlm.js
@@ -0,0 +1,54 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsImporterHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+Cu.import("resource:///modules/winCredentialStore.jsm");
+
+/* The importer below contains methods to retrieve configured
+ * Windows Live Messenger accounts.
+ *
+ * Homepage: http://windows.microsoft.com/en-US/windows-live/essentials-home
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation obtaining Windows Live Messenger
+ *     username and passwords from the Windows Credential Store.
+ */
+function windowsLiveMessengerImporter() { }
+windowsLiveMessengerImporter.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "Windows Live Messenger",
+  get id() "importer-wlm",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    // WLM stores user passwords in the Windows Credential Store.
+    let credStore = new CredentialStore();
+
+    // Filter the credentials found with the WLM prefix.
+    let credentials = credStore.getCredentials("WindowsLive:name=*");
+    for each (let cred in credentials) {
+      // Each credential from the filtered search is an MSN account.
+      let foundAccount = new ExistingAccount(cred.username, "prpl-msn", this.id);
+
+      // The Credential Blob stores the plaintext WLM password.
+      if (cred.credentialBlob)
+        foundAccount.password = cred.credentialBlob;
+      this._returnAccount(foundAccount);
+    }
+
+    // Properly close the DLL library access by js-ctypes.
+    credStore.shutdown();
+    this._endAccountSearch();
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{03cc0f7e-f208-4183-8150-769f979bee24}")
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([windowsLiveMessengerImporter]);
diff --git a/chat/importers/wlm.manifest b/chat/importers/wlm.manifest
new file mode 100644
--- /dev/null
+++ b/chat/importers/wlm.manifest
@@ -0,0 +1,3 @@
+component {03cc0f7e-f208-4183-8150-769f979bee24} wlm.js
+contract @mozilla.org/chat/wlmimporter;1 {03cc0f7e-f208-4183-8150-769f979bee24}
+category im-import-plugin importer-wlm @mozilla.org/chat/wlmimporter;1
diff --git a/chat/importers/xchat.js b/chat/importers/xchat.js
new file mode 100644
--- /dev/null
+++ b/chat/importers/xchat.js
@@ -0,0 +1,201 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsImporterHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+Cu.import("resource://gre/modules/NetUtil.jsm");
+
+const kLineBreak = "@mozilla.org/windows-registry-key;1" in Cc ? "\r\n" : "\n";
+
+/* The importer below contains methods to retrieve the
+ * IRC accounts from the XChat IRC client.
+ *
+ * Homepage: http://xchat.org/
+ * Resources:
+ *   Official XChat FAQ
+ *     http://xchat.org/faq/#q222
+ *   Details about XChat's profile directory.
+ *     http://xchatdata.net/Using/ProfileDirectory
+ *
+ * Currently supports:
+ *   - A findAccounts() implementation reading the user and server
+ *     IRC information along with supported preferences.
+ */
+function xchatImporter() { }
+xchatImporter.prototype = {
+  __proto__: GenericImporterPrototype,
+  get name() "XChat",
+  get id() "importer-xchat",
+
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+
+    this._xchatConfig = this._getXChatConfiguration();
+    if (!this._xchatConfig.exists()) {
+      this._endAccountSearch();
+      return;
+    }
+
+    let xchatServerList = this._getXChatDirectory();
+    xchatServerList.append("servlist_.conf");
+    if (!xchatServerList.exists()) {
+      this._endAccountSearch();
+      return;
+    }
+
+    // Both the XChat configuration file and server list must be read
+    // asynchronously before parsing.
+    NetUtil.asyncFetch(xchatServerList, function(stream, status) {
+      if (!Components.isSuccessCode(status)) {
+        this._endAccountSearch();
+        return;
+      }
+      this._serverList = NetUtil.readInputStreamToString(stream, stream.available());
+
+      NetUtil.asyncFetch(this._xchatConfig, function(stream, status) {
+        if (!Components.isSuccessCode(status)) {
+          this._endAccountSearch();
+          return;
+        }
+        let config = NetUtil.readInputStreamToString(stream, stream.available());
+        this._parseXChatConfig(config, this._serverList);
+      }.bind(this));
+    }.bind(this));
+  },
+
+  // This method handles the parsing of the XChat configuration file
+  // into ExistingAccount objects.
+  _parseXChatConfig: function(aConfig, aServlist) {
+    let settings = {
+      name: '',
+      server: {host: '', port: ''},
+      partmsg: '',
+      quitmsg: ''
+    };
+    let entries = aConfig.split("\n");
+
+    for each (entry in entries) {
+      entry = entry.split(" = ");
+      switch (entry[0]) {
+        case "irc_nick1":
+          settings.name = entry[1];
+          break;
+        case "gui_slist_select":
+          let serverIndex = parseInt(entry[1]);
+          let curServer = this._getXChatServer(serverIndex, aServlist);
+          if (curServer) {
+            if (curServer.indexOf("/")) {
+              curServer = curServer.split("/");
+              settings.server.host = curServer[0];
+              settings.server.port = parseInt(curServer[1]);
+            }
+            else
+              settings.server.host = curServer;
+          }
+          break;
+        case "irc_part_reason":
+          settings.partmsg = entry[1];
+          break;
+        case "irc_quit_reason":
+          settings.quitmsg = entry[1];
+          break;
+      }
+    }
+
+    if (!settings.name || !settings.server.host) {
+      this._endAccountSearch();
+      return;
+    }
+
+    let name = settings.name + "@" + settings.server.host;
+    let foundAccount = new ExistingAccount(name, "prpl-irc", this.id);
+
+    if (settings.server.port)
+      foundAccount.setInt("port", settings.server.port);
+    if (settings.quitmsg)
+      foundAccount.setString("quitmsg", settings.quitmsg);
+    if (settings.partmsg)
+      foundAccount.setString("partmsg", settings.partmsg);
+
+    this._returnAccount(foundAccount);
+    this._endAccountSearch();
+  },
+
+  /* While an "xchat.conf" file stores the selected server index,
+     a "servlist_.conf" file lists these servers. This method parses
+     this long list of servers to retrieve the specific one that
+     the user was last using.
+
+     A typical servlist_.conf starts as follows:
+
+       v=2.8.9
+
+       N=Aservername
+       E=IRC (Latin/Unicode Hybrid)
+       F=19
+       D=0
+       S=irc.aserver.net
+
+       N=Bserver name
+       E=IRC (Latin/Unicode Hybrid)
+       F=19
+       D=0
+       S=irc.bserver.net
+
+    There are several more entries in the default servlist_.conf, which
+    follow the above pattern. This method parses this format by splitting
+    by double newlines (\n\n) to get each server section, then splitting
+    by the single newline (\n) to get each sections individual name=value
+    pairs. The target key is "S=", which will give the server url. */
+  _getXChatServer: function(aServerIndex, aServerList) {
+    if (!aServerList)
+      return undefined;
+
+    let serverConfigs = aServerList.split(kLineBreak + kLineBreak);
+    if (serverConfigs.length < aServerIndex) {
+      Cu.reportError("_getXChatServer: aServerIndex out of bounds.");
+      return undefined;
+    }
+
+    // The index is incremented by 1 to offset the "v=#.#.#" entry (see above).
+    let selectedConfig = serverConfigs[aServerIndex + 1].split("\n");
+    for each (let entry in selectedConfig) {
+      entry = entry.split("=");
+      if (entry[0] == "S")
+        return entry[1];
+    }
+    return undefined;
+  },
+
+  // On Windows machines, the XChat directory is "X-Chat 2" in AppData,
+  // while in Linux the directory is ".xchat2". Both OS have the same
+  // files present despite this.
+  _getXChatDirectory: function() {
+    let xchatDir;
+    if (Services.appinfo.OS != "WINNT") {
+      xchatDir = Services.dirsvc.get("Home", Ci.nsIFile);
+      xchatDir.append(".xchat2");
+    } else {
+      xchatDir = Services.dirsvc.get("AppData", Ci.nsIFile);
+      xchatDir.append("X-Chat 2");
+    }
+    return xchatDir;
+  },
+
+  // This is a shortcut method to grab the "xchat.conf" nsIFile, which
+  // stores several "name=value" pairs.
+  _getXChatConfiguration: function() {
+    let xchatConfig = this._getXChatDirectory().clone();
+    xchatConfig.append("xchat.conf");
+    return xchatConfig;
+  },
+
+  QueryInterface: XPCOMUtils.generateQI([Ci.imIImporter]),
+  classID: Components.ID("{9043aa53-d133-4ca9-a5ce-01dc22ee5159}")
+};
+
+const NSGetFactory = XPCOMUtils.generateNSGetFactory([xchatImporter]);
diff --git a/chat/importers/xchat.manifest b/chat/importers/xchat.manifest
new file mode 100644
--- /dev/null
+++ b/chat/importers/xchat.manifest
@@ -0,0 +1,3 @@
+component {9043aa53-d133-4ca9-a5ce-01dc22ee5159} xchat.js
+contract @mozilla.org/chat/xchatimporter;1 {9043aa53-d133-4ca9-a5ce-01dc22ee5159}
+category im-import-plugin importer-xchat @mozilla.org/chat/xchatimporter;1
diff --git a/chat/makefiles.sh b/chat/makefiles.sh
--- a/chat/makefiles.sh
+++ b/chat/makefiles.sh
@@ -2,16 +2,17 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 add_makefiles "
 chat/Makefile
 chat/components/public/Makefile
 chat/components/src/Makefile
 chat/content/Makefile
+chat/importers/Makefile
 chat/locales/Makefile
 chat/modules/Makefile
 chat/protocols/facebook/Makefile
 chat/protocols/gtalk/Makefile
 chat/protocols/irc/Makefile
 chat/protocols/jsTest/Makefile
 chat/protocols/twitter/Makefile
 chat/protocols/xmpp/Makefile
diff --git a/chat/modules/Makefile.in b/chat/modules/Makefile.in
--- a/chat/modules/Makefile.in
+++ b/chat/modules/Makefile.in
@@ -11,20 +11,28 @@ include $(DEPTH)/config/autoconf.mk
 
 EXTRA_JS_MODULES = \
 	imContentSink.jsm \
 	imServices.jsm \
 	imSmileys.jsm \
 	imStatusUtils.jsm \
 	imThemes.jsm \
 	imXPCOMUtils.jsm \
+	jsImporterHelper.jsm \
 	jsProtoHelper.jsm \
 	socket.jsm \
 	$(NULL)
 
+ifeq ($(OS_ARCH),WINNT)
+EXTRA_JS_MODULES += \
+	blowfish.jsm \
+	winCredentialStore.jsm \
+	$(NULL)
+endif
+
 ifndef MOZ_THUNDERBIRD
 EXTRA_JS_MODULES += http.jsm
 endif
 
 EXTRA_PP_JS_MODULES = \
 	hiddenWindow.jsm \
 	imTextboxUtils.jsm \
 	$(NULL)
diff --git a/chat/modules/blowfish.jsm b/chat/modules/blowfish.jsm
new file mode 100644
--- /dev/null
+++ b/chat/modules/blowfish.jsm
@@ -0,0 +1,379 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const EXPORTED_SYMBOLS = ["Blowfish"];
+
+// This is an implementation of the Blowfish cipher by Bruce Schneier. For
+// more information, see http://www.schneier.com/paper-blowfish-fse.html.
+// This implementation passes the test vectors provided on the above site, which
+// can be tested in chat/importers/test/test_aim_Blowfish.js. It should not be
+// considered secure for sensitive information.
+// The key used in the constructor should be passed as an Uint8Array.
+function Blowfish(aKey) {
+  // The P and S arrays are initialized with the digits of pi.
+  this._P = this.P;
+  this._S1 = this.S1;
+  this._S2 = this.S2;
+  this._S3 = this.S3;
+  this._S4 = this.S4;
+
+  // Calculate the subkeys based on the provided key and initial P and S arrays.
+  // Pad the key to 56 bytes, cycling the given key values.
+  let j = 0;
+  let keyArray = [aKey[i] for (i in aKey)];
+  while (keyArray.length < 72) {
+    keyArray.push(keyArray[j++]);
+    if (j >= aKey.length)
+      j = 0;
+  }
+  aKey = Uint8Array(keyArray);
+
+  // XOR the P array with 32-bit sections of the key.
+  for (let i = 0; i < this._P.length; ++i) {
+    // TODO: Use DataView in Gecko 15. Below is a fix for the endianness issues
+    // until then, inspired from:
+    // https://github.com/bwhmather/blowfish.js/blob/master/lib/blowfish.js#L546
+    let keyInt = 0;
+    for (let j = 0; j < 4; ++j)
+      keyInt = ((keyInt << 8) | aKey[(i * 4) + j]) >>> 0;
+
+    this._P[i] ^= keyInt;
+  }
+
+  // Encrypt an all-zero block with the Blowfish algorithm and use the result
+  // to repopulate the P array.
+  let populateBlock = new Uint32Array([0x00000000, 0x00000000]);
+  for (let i = 0; i < this._P.length; i += 2) {
+    populateBlock = this._encryptBlock(populateBlock);
+    this._P[i] = populateBlock[0];
+    this._P[i + 1] = populateBlock[1];
+  }
+
+  // Encrypt an all-zero block to repopulate the S arrays.
+  for (let i = 0; i < this._S1.length; i += 2) {
+    populateBlock = this._encryptBlock(populateBlock);
+    this._S1[i] = populateBlock[0];
+    this._S1[i + 1] = populateBlock[1];
+  }
+  for (let i = 0; i < this._S2.length; i += 2) {
+    populateBlock = this._encryptBlock(populateBlock);
+    this._S2[i] = populateBlock[0];
+    this._S2[i + 1] = populateBlock[1];
+  }
+  for (let i = 0; i < this._S3.length; i += 2) {
+    populateBlock = this._encryptBlock(populateBlock);
+    this._S3[i] = populateBlock[0];
+    this._S3[i + 1] = populateBlock[1];
+  }
+  for (let i = 0; i < this._S4.length; i += 2) {
+    populateBlock = this._encryptBlock(populateBlock);
+    this._S4[i] = populateBlock[0];
+    this._S4[i + 1] = populateBlock[1];
+  }
+}
+Blowfish.prototype = {
+  // Procedure to swap endianness, should be removed when replacing array access
+  // with DataView. Inspired by: http://stackoverflow.com/q/5320439/1168121
+  _swapEndianness: function(aWord) {
+    return ((aWord & 0xFF) << 24) | ((aWord & 0xFF00) << 8)
+           | ((aWord >> 8) & 0xFF00) | ((aWord >> 24) & 0xFF);
+  },
+
+  // Blowfish is a block cipher that acts on 8 byte "blocks" of data. This
+  // method encrypts a block of data, receiving and returning a Uint32Array.
+  _encryptBlock: function(aBlock) {
+    let [xL, xR] = [aBlock[0], aBlock[1]];
+
+    for (let i = 0; i < 16; ++i) {
+      xL ^= this._P[i];
+      xR = this._round(xL) ^ xR;
+
+      // Swap xL and xR
+      [xL, xR] = [xR, xL];
+    }
+
+    // Swap xL and xR again.
+    [xL, xR] = [xR, xL];
+
+    xR ^= this._P[16];
+    xL ^= this._P[17];
+
+    return new Uint32Array([xL, xR]);
+  },
+
+  // Blowfish decrypts a block of data by reversing the order of P array access.
+  _decryptBlock: function(aBlock) {
+    let [xL, xR] = [aBlock[0], aBlock[1]];
+
+    for (let i = 17; i > 1; --i) {
+      xL ^= this._P[i];
+      xR = this._round(xL) ^ xR;
+
+      // Swap xL and xR
+      [xL, xR] = [xR, xL];
+    }
+
+    // Swap xL and xR again.
+    [xL, xR] = [xR, xL];
+
+    xR ^= this._P[1];
+    xL ^= this._P[0];
+
+    return new Uint32Array([xL, xR]);
+  },
+
+  _round: function(aWord) {
+    // Divide the aWord into four 8-bit quarters
+    let a = aWord >> 24 & 0xFF;
+    let b = aWord >> 16 & 0xFF;
+    let c = aWord >> 8 & 0xFF;
+    let d = aWord >> 0 & 0xFF;
+
+    // Perform the feistel round function using the S arrays.
+    return ((this._S1[a] + this._S2[b]) ^ this._S3[c]) + this._S4[d];
+  },
+
+  // This procedure should be called when wanting to encrypt any information,
+  // rather than _encryptBlock(). A Uint8Array is received and returned.
+  encrypt: function(aPlainBytes) {
+    let blockArray = Uint32Array(aPlainBytes.buffer);
+
+    // Swapping endianness due to Uint32Array cast. (TODO: DataView)
+    for (let i = 0; i < blockArray.length; ++i)
+      blockArray[i] = this._swapEndianness(blockArray[i]);
+
+    // Pass each 64-bit block to the block cipher method.
+    let result = [];
+    for (let i = 0; i < blockArray.length; i += 2) {
+      let encryptedBlock = this._encryptBlock(blockArray.subarray(i, i+2));
+
+      result.push(encryptedBlock[0]);
+      result.push(encryptedBlock[1]);
+    }
+
+    let encryptedArray = new Uint32Array(result);
+
+    // Swapping endianness due to Uint32Array cast. (TODO: DataView)
+    for (let i = 0; i < encryptedArray.length; ++i)
+      encryptedArray[i] = this._swapEndianness(encryptedArray[i]);
+
+    // Return an unsigned 8-bit integer array
+    return Uint8Array(encryptedArray.buffer);
+  },
+
+  // This procedure should be called when wanting to decrypt any information,
+  // rather than _decryptBlock(). A Uint8Array is received and returned.
+  decrypt: function(aEncryptedBytes) {
+    let blockArray = Uint32Array(aEncryptedBytes.buffer);
+
+    // Swapping endianness due to Uint32Array cast. (TODO: DataView)
+    for (let i = 0; i < blockArray.length; ++i)
+      blockArray[i] = this._swapEndianness(blockArray[i]);
+
+    // Pass each 64-bit block to the block cipher method.
+    let result = [];
+    for (let i = 0; i < blockArray.length; i += 2) {
+      let decryptedBlock = this._decryptBlock(blockArray.subarray(i, i+2));
+      result.push(decryptedBlock[0]);
+      result.push(decryptedBlock[1]);
+    }
+
+    let decryptedArray = new Uint32Array(result);
+
+    // Swapping endianness due to Uint32Array cast. (TODO: DataView)
+    for (let i = 0; i < decryptedArray.length; ++i)
+      decryptedArray[i] = this._swapEndianness(decryptedArray[i]);
+
+    // Return an unsigned 8-bit integer array
+    return Uint8Array(decryptedArray.buffer);
+  },
+
+  // The P and S arrays below contain the digits of pi, as specified in the
+  // original Blowfish cipher. These constant starting values will be copied to
+  // _P, _S1, etc., and modified when the cipher is given a key.
+  get P() Uint32Array(
+    [0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344, 0xA4093822, 0x299F31D0,
+     0x082EFA98, 0xEC4E6C89, 0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
+     0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917, 0x9216D5D9, 0x8979FB1B]),
+
+  get S1() Uint32Array(
+    [0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7, 0xB8E1AFED, 0x6A267E96,
+     0xBA7C9045, 0xF12C7F99, 0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
+     0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E, 0x0D95748F, 0x728EB658,
+     0x718BCD58, 0x82154AEE, 0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
+     0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF, 0x8E79DCB0, 0x603A180E,
+     0x6C9E0E8B, 0xB01E8A3E, 0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
+     0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440, 0x55CA396A, 0x2AAB10B6,
+     0xB4CC5C34, 0x1141E8CE, 0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
+     0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E, 0xAFD6BA33, 0x6C24CF5C,
+     0x7A325381, 0x28958677, 0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
+     0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032, 0xEF845D5D, 0xE98575B1,
+     0xDC262302, 0xEB651B88, 0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
+     0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E, 0x21C66842, 0xF6E96C9A,
+     0x670C9C61, 0xABD388F0, 0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
+     0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98, 0xA1F1651D, 0x39AF0176,
+     0x66CA593E, 0x82430E88, 0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
+     0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6, 0x4ED3AA62, 0x363F7706,
+     0x1BFEDF72, 0x429B023D, 0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
+     0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7, 0xE3FE501A, 0xB6794C3B,
+     0x976CE0BD, 0x04C006BA, 0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
+     0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F, 0x6DFC511F, 0x9B30952C,
+     0xCC814544, 0xAF5EBD09, 0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
+     0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB, 0x5579C0BD, 0x1A60320A,
+     0xD6A100C6, 0x402C7279, 0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
+     0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB, 0x323DB5FA, 0xFD238760,
+     0x53317B48, 0x3E00DF82, 0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
+     0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573, 0x695B27B0, 0xBBCA58C8,
+     0xE1FFA35D, 0xB8F011A0, 0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
+     0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790, 0xE1DDF2DA, 0xA4CB7E33,
+     0x62FB1341, 0xCEE4C6E8, 0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
+     0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0, 0xD08ED1D0, 0xAFC725E0,
+     0x8E3C5B2F, 0x8E7594B7, 0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
+     0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD, 0x2F2F2218, 0xBE0E1777,
+     0xEA752DFE, 0x8B021FA1, 0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
+     0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9, 0x165FA266, 0x80957705,
+     0x93CC7314, 0x211A1477, 0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
+     0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49, 0x00250E2D, 0x2071B35E,
+     0x226800BB, 0x57B8E0AF, 0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
+     0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5, 0x83260376, 0x6295CFA9,
+     0x11C81968, 0x4E734A41, 0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
+     0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400, 0x08BA6FB5, 0x571BE91F,
+     0xF296EC6B, 0x2A0DD915, 0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
+     0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A]),
+
+  get S2() Uint32Array(
+    [0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623, 0xAD6EA6B0, 0x49A7DF7D,
+     0x9CEE60B8, 0x8FEDB266, 0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
+     0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E, 0x3F54989A, 0x5B429D65,
+     0x6B8FE4D6, 0x99F73FD6, 0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
+     0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E, 0x09686B3F, 0x3EBAEFC9,
+     0x3C971814, 0x6B6A70A1, 0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
+     0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8, 0xB03ADA37, 0xF0500C0D,
+     0xF01C1F04, 0x0200B3FF, 0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
+     0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701, 0x3AE5E581, 0x37C2DADC,
+     0xC8B57634, 0x9AF3DDA7, 0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
+     0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331, 0x4E548B38, 0x4F6DB908,
+     0x6F420D03, 0xF60A04BF, 0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
+     0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E, 0x5512721F, 0x2E6B7124,
+     0x501ADDE6, 0x9F84CD87, 0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
+     0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2, 0xEF1C1847, 0x3215D908,
+     0xDD433B37, 0x24C2BA16, 0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
+     0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B, 0x043556F1, 0xD7A3C76B,
+     0x3C11183B, 0x5924A509, 0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
+     0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3, 0x771FE71C, 0x4E3D06FA,
+     0x2965DCB9, 0x99E71D0F, 0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
+     0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4, 0xF2F74EA7, 0x361D2B3D,
+     0x1939260F, 0x19C27960, 0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
+     0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28, 0xC332DDEF, 0xBE6C5AA5,
+     0x65582185, 0x68AB9802, 0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
+     0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510, 0x13CCA830, 0xEB61BD96,
+     0x0334FE1E, 0xAA0363CF, 0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
+     0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E, 0x648B1EAF, 0x19BDF0CA,
+     0xA02369B9, 0x655ABB50, 0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
+     0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8, 0xF837889A, 0x97E32D77,
+     0x11ED935F, 0x16681281, 0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
+     0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696, 0xCDB30AEB, 0x532E3054,
+     0x8FD948E4, 0x6DBC3128, 0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
+     0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0, 0x45EEE2B6, 0xA3AAABEA,
+     0xDB6C4F15, 0xFACB4FD0, 0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
+     0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250, 0xCF62A1F2, 0x5B8D2646,
+     0xFC8883A0, 0xC1C7B6A3, 0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
+     0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00, 0x58428D2A, 0x0C55F5EA,
+     0x1DADF43E, 0x233F7061, 0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
+     0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E, 0xA6078084, 0x19F8509E,
+     0xE8EFD855, 0x61D99735, 0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
+     0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9, 0xDB73DBD3, 0x105588CD,
+     0x675FDA79, 0xE3674340, 0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
+     0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7]),
+
+  get S3() Uint32Array(
+    [0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934, 0x411520F7, 0x7602D4F7,
+     0xBCF46B2E, 0xD4A20068, 0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
+     0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840, 0x4D95FC1D, 0x96B591AF,
+     0x70F4DDD3, 0x66A02F45, 0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
+     0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A, 0x28507825, 0x530429F4,
+     0x0A2C86DA, 0xE9B66DFB, 0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
+     0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6, 0xAACE1E7C, 0xD3375FEC,
+     0xCE78A399, 0x406B2A42, 0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
+     0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2, 0x3A6EFA74, 0xDD5B4332,
+     0x6841E7F7, 0xCA7820FB, 0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
+     0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B, 0x55A867BC, 0xA1159A58,
+     0xCCA92963, 0x99E1DB33, 0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
+     0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3, 0x95C11548, 0xE4C66D22,
+     0x48C1133F, 0xC70F86DC, 0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
+     0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564, 0x257B7834, 0x602A9C60,
+     0xDFF8E8A3, 0x1F636C1B, 0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
+     0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922, 0x85B2A20E, 0xE6BA0D99,
+     0xDE720C8C, 0x2DA2F728, 0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
+     0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E, 0x0A476341, 0x992EFF74,
+     0x3A6F6EAB, 0xF4F8FD37, 0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
+     0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804, 0xF1290DC7, 0xCC00FFA3,
+     0xB5390F92, 0x690FED0B, 0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
+     0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB, 0x37392EB3, 0xCC115979,
+     0x8026E297, 0xF42E312D, 0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
+     0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350, 0x1A6B1018, 0x11CAEDFA,
+     0x3D25BDD8, 0xE2E1C3C9, 0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
+     0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE, 0x9DBC8057, 0xF0F7C086,
+     0x60787BF8, 0x6003604D, 0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
+     0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F, 0x77A057BE, 0xBDE8AE24,
+     0x55464299, 0xBF582E61, 0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
+     0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9, 0x7AEB2661, 0x8B1DDF84,
+     0x846A0E79, 0x915F95E2, 0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
+     0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E, 0xB77F19B6, 0xE0A9DC09,
+     0x662D09A1, 0xC4324633, 0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
+     0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169, 0xDCB7DA83, 0x573906FE,
+     0xA1E2CE9B, 0x4FCD7F52, 0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
+     0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5, 0xF0177A28, 0xC0F586E0,
+     0x006058AA, 0x30DC7D62, 0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
+     0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76, 0x6F05E409, 0x4B7C0188,
+     0x39720A3D, 0x7C927C24, 0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
+     0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4, 0x1E50EF5E, 0xB161E6F8,
+     0xA28514D9, 0x6C51133C, 0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
+     0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0]),
+
+  get S4() Uint32Array(
+    [0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B, 0x5CB0679E, 0x4FA33742,
+     0xD3822740, 0x99BC9BBE, 0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
+     0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4, 0x5748AB2F, 0xBC946E79,
+     0xC6A376D2, 0x6549C2C8, 0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
+     0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304, 0xA1FAD5F0, 0x6A2D519A,
+     0x63EF8CE2, 0x9A86EE22, 0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
+     0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6, 0x2826A2F9, 0xA73A3AE1,
+     0x4BA99586, 0xEF5562E9, 0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
+     0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593, 0xE990FD5A, 0x9E34D797,
+     0x2CF0B7D9, 0x022B8B51, 0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
+     0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C, 0xE029AC71, 0xE019A5E6,
+     0x47B0ACFD, 0xED93FA9B, 0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
+     0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C, 0x15056DD4, 0x88F46DBA,
+     0x03A16125, 0x0564F0BD, 0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
+     0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319, 0x7533D928, 0xB155FDF5,
+     0x03563482, 0x8ABA3CBB, 0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
+     0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991, 0xEA7A90C2, 0xFB3E7BCE,
+     0x5121CE64, 0x774FBE32, 0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
+     0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166, 0xB39A460A, 0x6445C0DD,
+     0x586CDECF, 0x1C20C8AE, 0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
+     0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5, 0x72EACEA8, 0xFA6484BB,
+     0x8D6612AE, 0xBF3C6F47, 0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
+     0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D, 0x4040CB08, 0x4EB4E2CC,
+     0x34D2466A, 0x0115AF84, 0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
+     0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8, 0x611560B1, 0xE7933FDC,
+     0xBB3A792B, 0x344525BD, 0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
+     0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7, 0x1A908749, 0xD44FBD9A,
+     0xD0DADECB, 0xD50ADA38, 0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
+     0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C, 0xBF97222C, 0x15E6FC2A,
+     0x0F91FC71, 0x9B941525, 0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
+     0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442, 0xE0EC6E0E, 0x1698DB3B,
+     0x4C98A0BE, 0x3278E964, 0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
+     0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8, 0xDF359F8D, 0x9B992F2E,
+     0xE60B6F47, 0x0FE3F11D, 0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
+     0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299, 0xF523F357, 0xA6327623,
+     0x93A83531, 0x56CCCD02, 0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
+     0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614, 0xE6C6C7BD, 0x327A140A,
+     0x45E1D006, 0xC3F27B9A, 0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
+     0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B, 0x53113EC0, 0x1640E3D3,
+     0x38ABBD60, 0x2547ADF0, 0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
+     0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E, 0x1948C25C, 0x02FB8A8C,
+     0x01C36AE4, 0xD6EBE1F9, 0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
+     0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6])
+};
diff --git a/chat/modules/imServices.jsm b/chat/modules/imServices.jsm
--- a/chat/modules/imServices.jsm
+++ b/chat/modules/imServices.jsm
@@ -23,8 +23,11 @@ XPCOMUtils.defineLazyServiceGetter(Servi
                                    "@mozilla.org/chat/conversations-service;1",
                                    "imIConversationsService");
 XPCOMUtils.defineLazyServiceGetter(Services, "tags",
                                    "@mozilla.org/chat/tags-service;1",
                                    "imITagsService");
 XPCOMUtils.defineLazyServiceGetter(Services, "logs",
                                    "@mozilla.org/chat/logger;1",
                                    "imILogger");
+XPCOMUtils.defineLazyServiceGetter(Services, "importers",
+                                   "@mozilla.org/chat/importers-service;1",
+                                   "imIImportersService");
diff --git a/chat/modules/jsImporterHelper.jsm b/chat/modules/jsImporterHelper.jsm
new file mode 100644
--- /dev/null
+++ b/chat/modules/jsImporterHelper.jsm
@@ -0,0 +1,141 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const EXPORTED_SYMBOLS = [
+  "ExistingAccount",
+  "GenericImporterPrototype",
+  "ImporterConversation"
+];
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource:///modules/imXPCOMUtils.jsm");
+Cu.import("resource:///modules/jsProtoHelper.jsm");
+Cu.import("resource:///modules/imServices.jsm");
+
+initLogModule("jsImporterHelper", this);
+
+function ExistingAccount(aName, aProtocolId, aImporterId) {
+  this._name = aName;
+  this._protoId = aProtocolId;
+  this._importerId = aImporterId;
+  this._options = [];
+}
+ExistingAccount.prototype = {
+  __proto__: ClassInfo("imIExistingAccount", "existing account generic object"),
+
+  get name() this._name,
+  get protocolId() this._protoId,
+  get importerId() this._importerId,
+
+  autoLogin: false,
+  dateModified: 0,
+  password: "",
+  alias: "",
+
+  getOptions: function() {
+    if (!this._options)
+      return EmptyEnumerator;
+    return new nsSimpleEnumerator(this._options);
+  },
+  setBool: function(aName, aVal) {
+    this._setOption(aName, aVal, Ci.prplIPref.typeBool, "getBool");
+  },
+  setInt: function(aName, aVal) {
+    this._setOption(aName, aVal, Ci.prplIPref.typeInt, "getInt");
+  },
+  setString: function(aName, aVal) {
+    if (this._setOption(aName, aVal, Ci.prplIPref.typeString, "getString"))
+      return;
+    this._setOption(aName, aVal, Ci.prplIPref.typeList, "getListDefault");
+  },
+  _setOption: function(aName, aVal, aType, aGetMethod) {
+    let protoId = this._protoId;
+    let protoOptions = Services.core.getProtocolById(protoId).getOptions();
+    while (protoOptions.hasMoreElements()) {
+      let opt = protoOptions.getNext().QueryInterface(Ci.prplIPref);
+      if (opt.type == aType && opt.name == aName) {
+        // Create a new preference with the new value (in 'default' property)
+        let newOpt = new purplePref(aName, {label: opt.label, default: aVal});
+
+        // Avoid keeping track of a default preference.
+        if (opt[aGetMethod]() != newOpt[aGetMethod]()) {
+          this._options.push(newOpt);
+          return true;
+        }
+        return false;
+      }
+    }
+  }
+};
+
+const GenericImporterPrototype = {
+  __proto__: ClassInfo("imIImporter", "generic importer object"),
+
+  // The XPCShell tests access the importer JS Object.
+  get wrappedJSObject() this,
+
+  // Methods defined in the imIImporter interface.
+  findAccounts: function(aObserver) {
+    this._observer = aObserver;
+    this._endAccountSearch();
+  },
+  importData: function(aAccount, aPreference, aObserver) {
+    this._observer = aObserver;
+    this._updateImportStatus(aAccount, null);
+  },
+
+  // Helper methods for observer notifications.
+  _returnAccount: function(aExistingAccount) {
+    this._observer.observe(aExistingAccount, "existing-account-found", null);
+  },
+  _endAccountSearch: function() {
+    this._observer.observe(this, "account-search-finished", null);
+  },
+  _updateImportStatus: function(aAccount, aPreference) {
+    this._observer.observe(aAccount, "import-status-updated", aPreference);
+  }
+};
+
+function ImporterConversation(aName, aAccount, aIsChat, aBuddy) {
+  this._name = aName;
+  this._account = aAccount;
+  this._isChat = aIsChat;
+  this.buddy = aBuddy;
+  this._observers = [];
+  // TODO: Method of assigning ID outside of ConversationService?
+  this._id = Math.random() * 9999;
+}
+ImporterConversation.prototype = {
+  __proto__: ClassInfo("prplIConversation", "importer conversation object"),
+
+  get account() this._account,
+  get name() this._name,
+  get normalizedName() this._name,
+  get title() this._name,
+  get id() this._id,
+  get isChat() this._isChat,
+
+  addObserver: function(aObserver) {
+    if (this._observers.indexOf(aObserver) === -1)
+      this._observers.push(aObserver);
+  },
+  removeObserver: function(aObserver) {
+    this._observers = this._observers.filter(function(o) o !== aObserver);
+  },
+  notifyObservers: function(aSubject, aTopic, aData) {
+    for each (let observer in this._observers)
+      observer.observe(aSubject, aTopic, aData);
+  },
+
+  close: function() {},
+  unInit: function() {
+    delete this._account;
+    delete this._observers;
+    this.notifyObservers(this, "conversation-closed", null);
+  },
+  writeMessage: function(aWho, aText, aProperties) {
+    (new Message(aWho, aText, aProperties)).conversation = this;
+  }
+};
diff --git a/chat/modules/jsProtoHelper.jsm b/chat/modules/jsProtoHelper.jsm
--- a/chat/modules/jsProtoHelper.jsm
+++ b/chat/modules/jsProtoHelper.jsm
@@ -1,22 +1,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const EXPORTED_SYMBOLS = [
+  "ForwardProtocolPrototype",
   "GenericAccountPrototype",
   "GenericAccountBuddyPrototype",
   "GenericConvIMPrototype",
   "GenericConvChatPrototype",
   "GenericConvChatBuddyPrototype",
   "GenericMessagePrototype",
   "GenericProtocolPrototype",
-  "ForwardProtocolPrototype",
   "Message",
+  "purplePref",
   "TooltipInfo"
 ];
 
 const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu} = Components;
 
 Cu.import("resource:///modules/imXPCOMUtils.jsm");
 Cu.import("resource:///modules/imServices.jsm");
 
@@ -321,19 +322,25 @@ const GenericMessagePrototype = {
   _lastId: 0,
   _init: function (aWho, aMessage, aObject) {
     this.id = ++GenericMessagePrototype._lastId;
     this.time = Math.round(new Date() / 1000);
     this.who = aWho;
     this.message = aMessage;
     this.originalMessage = aMessage;
 
-    if (aObject)
-      for (let i in aObject)
-        this[i] = aObject[i];
+    if (aObject) {
+      for (let i in aObject) {
+        if (i !== "conversation")
+          this[i] = aObject[i];
+      }
+      // The message should not be sent off until all properties are set.
+      if (aObject.conversation)
+        this.conversation = aObject.conversation;
+    }
   },
   _alias: "",
   get alias() this._alias || this.who,
   _iconURL: "",
   get iconURL() {
     // If the protocol plugin has explicitly set an icon for the message, use it.
     if (this._iconURL)
       return this._iconURL;
diff --git a/chat/modules/winCredentialStore.jsm b/chat/modules/winCredentialStore.jsm
new file mode 100644
--- /dev/null
+++ b/chat/modules/winCredentialStore.jsm
@@ -0,0 +1,200 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const EXPORTED_SYMBOLS = ["CredentialStore"];
+
+Components.utils.import("resource:///modules/imXPCOMUtils.jsm");
+Components.utils.import("resource://gre/modules/ctypes.jsm");
+
+const DWORD = ctypes.uint32_t;
+const LPBYTE = ctypes.PointerType(ctypes.jschar);
+const LPTSTR = ctypes.PointerType(ctypes.jschar);
+const LPCTSTR = ctypes.PointerType(ctypes.jschar);
+const PVOID = ctypes.PointerType(ctypes.void_t);
+
+// "Contains a 64-bit value representing the number of 100-nanosecond intervals
+// since January 1, 1601 (UTC)."
+//  http://msdn.microsoft.com/en-us/library/ms724284.aspx
+const FILETIME = ctypes.StructType("FILETIME", [
+        {'dwLowDateTime': DWORD},
+        {'dwHighDateTime': DWORD}
+      ]);
+
+// "The CREDENTIAL_ATTRIBUTE structure contains an application-defined attribute
+// of the credential. An attribute is a keyword-value pair."
+//  http://msdn.microsoft.com/en-us/library/aa374790.aspx
+const CREDENTIAL_ATTRIBUTE = ctypes.StructType("CREDENTIAL_ATTRIBUTE", [
+        {'Keyword': LPTSTR},
+        {'Flags': DWORD},
+        {'ValueSize': DWORD},
+        {'Value': LPBYTE}
+      ]);
+const PCREDENTIAL_ATTRIBUTE = ctypes.PointerType(CREDENTIAL_ATTRIBUTE);
+
+// "The CREDENTIAL structure contains a single credential."
+//  http://msdn.microsoft.com/en-us/library/aa374788.aspx
+const CREDENTIAL = ctypes.StructType("CREDENTIAL", [
+        {'Flags': DWORD},
+        {'Type': DWORD},
+        {'TargetName': LPTSTR},
+        {'Comment': LPTSTR},
+        {'LastWritten': FILETIME},
+        {'CredentialBlobSize': DWORD},
+        {'CredentialBlob': LPBYTE},
+        {'Persist': DWORD},
+        {'AttributeCount': DWORD},
+        {'Attributes': PCREDENTIAL_ATTRIBUTE},
+        {'TargetAlias': LPTSTR},
+        {'UserName': LPTSTR}
+      ]);
+const PCREDENTIAL = ctypes.PointerType(CREDENTIAL);
+// PCREDENTIAL_ARRAY is not defined on MSDN, but there must be constant
+// reference to the type for CredEnumerate to work.
+const PCREDENTIAL_ARRAY = ctypes.ArrayType(PCREDENTIAL).ptr;
+
+function CredentialStore() {
+  this._credentialLib.init();
+}
+CredentialStore.prototype = {
+  // The CredentialStore should be shutdown after use.
+  shutdown: function() {
+    this._credentialLib.shutdown();
+  },
+
+  // Returns an array of Credential objects.
+  //  aFilter: A string to filter the returned credentials by TargetName.
+  //           An asterisk can be used as a wildcard; null for no filter.
+  getCredentials: function(aFilter) {
+    let count = DWORD();
+    let credentials = PCREDENTIAL_ARRAY();
+    let result = this._credentialLib.CredEnumerate(aFilter, 0,
+                                                   count.address(),
+                                                   credentials.address());
+
+    if (!result || !count.value)
+      return [];
+
+    // The unbounded PCREDENTIAL_ARRAY must be cast to a fixed-length array.
+    let castCredentials =
+      ctypes.cast(credentials, PCREDENTIAL.array(count.value).ptr);
+
+    let credArray = [];
+    for (let i = 0; i < count.value; ++i) {
+      let cred = new Credential(castCredentials.contents[i].contents);
+      credArray.push(cred);
+    }
+
+    // Credentials must be "freed." This is done after reading the values.
+    this._credentialLib.CredFree(credentials);
+    return credArray;
+  },
+
+  _credentialLib: {
+    // The "Advanced Windows 32 Base API DLL" has methods for
+    // access of the Windows Credential Store.
+    advapi32: null,
+    shutdown: function() {
+      this.advapi32.close()
+    },
+    init: function() {
+      this.advapi32 = ctypes.open("Advapi32");
+
+      // Low-level Credentials Management Functions
+
+      // "The CredEnumerate function enumerates the credentials from
+      // the user's credential set."
+      //  http://msdn.microsoft.com/en-us/library/aa374794.aspx
+      this.CredEnumerate = this.advapi32.declare("CredEnumerateW",
+        ctypes.default_abi,
+        ctypes.bool,
+        LPCTSTR,       // Filter
+        DWORD,         // Flags
+        DWORD.ptr,     // *Count
+        PCREDENTIAL_ARRAY.ptr // **Credentials
+      );
+
+      // "The CredFree function frees a buffer returned by any of
+      // the credentials management functions."
+      //  http://msdn.microsoft.com/en-us/library/aa374796.aspx
+      this.CredFree = this.advapi32.declare("CredFree",
+        ctypes.default_abi,
+        ctypes.void_t,
+        PVOID  // Buffer
+      );
+    }
+  }
+};
+
+// This is a JavaScript object that represents the CREDENTIAL struct
+// without js-ctypes. These are interacted with after a call to
+// getCredentials() in CredentialStore.
+function Credential(aCredStruct) {
+  // "A bit member that identifies characteristics of the credential."
+  // The bits are defined below (flagValues)
+  this.flags = aCredStruct.Flags;
+
+  // "The type of the credential."
+  this.type = aCredStruct.Type;
+
+  // "The name of the credential. The TargetName and Type members
+  // uniquely identify the credential."
+  this.targetName = aCredStruct.TargetName.readString();
+
+  // "A string comment from the user that describes this credential. This member
+  // cannot be longer than CRED_MAX_STRING_LENGTH (256) characters."
+  if (!aCredStruct.Comment.isNull())
+    this.comment = aCredStruct.Comment.readString();
+
+  // "The time, in Coordinated Universal Time (Greenwich Mean Time),
+  // of the last modification of the credential."
+  this.lastWritten = aCredStruct.LastWritten.contents;
+
+  // "The size, in bytes, of the CredentialBlob member. This member cannot
+  // be larger than CRED_MAX_CREDENTIAL_BLOB_SIZE (512) bytes."
+  this.credentialBlobSize = aCredStruct.CredentialBlobSize;
+
+  // "Secret data for the credential.
+  // - If the Type member is CRED_TYPE_DOMAIN_PASSWORD, this member
+  //   contains the plaintext Unicode password for UserName.
+  // - If the Type member is CRED_TYPE_DOMAIN_CERTIFICATE, this member
+  //   contains the clear test Unicode PIN for UserName.
+  // - If the Type member is CRED_TYPE_GENERIC, this member is
+  //   defined by the application.
+  // The application defines the byte-endian and alignment of the
+  // data in CredentialBlob."
+  if (this.credentialBlobSize)
+    this.credentialBlob = aCredStruct.CredentialBlob.readString();
+
+  // Defines the persistence of this credential.
+  this.persist = aCredStruct.Persist;
+
+  // "Alias for the TargetName member." The credential manager
+  // ignores the value for CRED_TYPE_GENERIC credentials.
+  if (!aCredStruct.TargetAlias.isNull() &&
+      this.type != this.typeValues.CRED_TYPE_GENERIC) {
+    this.targetAlias = aCredStruct.TargetAlias.readString();
+  }
+
+  // "The user name of the account used to connect to TargetName.
+  // - If the credential Type is CRED_TYPE_DOMAIN_PASSWORD, this member
+  //   can be either a 'DomainName\UserName' or a UPN.
+  // - If the credential Type is CRED_TYPE_DOMAIN_CERTIFICATE, this member
+  //   must be a marshaled certificate reference created by calling
+  //   CredMarshalCredential with a CertCredential.
+  // - If the credential Type is CRED_TYPE_GENERIC, this member can be
+  //   non-NULL, but the credential manager ignores the member.
+  // This member cannot be longer than CRED_MAX_USERNAME_LENGTH characters.
+  if (!aCredStruct.UserName.isNull())
+    this.username = aCredStruct.UserName.readString();
+}
+Credential.prototype = {
+  typeValues: {
+    CRED_TYPE_GENERIC: 1,
+    CRED_TYPE_DOMAIN_PASSWORD: 2,
+    CRED_TYPE_DOMAIN_CERTIFICATE: 3,
+    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD: 4,
+    CRED_TYPE_GENERIC_CERTIFICATE: 5,
+    CRED_TYPE_DOMAIN_EXTENDED: 6
+  }
+};
diff --git a/instantbird/app/profile/all-instantbird.js b/instantbird/app/profile/all-instantbird.js
--- a/instantbird/app/profile/all-instantbird.js
+++ b/instantbird/app/profile/all-instantbird.js
@@ -87,16 +87,19 @@ pref("font.size.variable.x-western", 13)
 pref("font.size.variable.x-unicode", 13);
 pref("font.size.variable.x-central-euro", 13);
 pref("font.size.variable.x-cyrillic", 13);
 
 pref("messenger.proxies", "");
 pref("messenger.globalProxy", "none");
 pref("messenger.warnOnQuit", true);
 
+// Controls whether the account wizard searches for existing accounts to import.
+pref("messenger.importWizard.enabled", false);
+
 #ifdef XP_WIN
 pref("browser.preferences.instantApply", false);
 #else
 pref("browser.preferences.instantApply", true);
 #endif
 #ifdef XP_MACOSX
 pref("browser.preferences.animateFadeIn", true);
 #else
diff --git a/instantbird/content/accountWizard.css b/instantbird/content/accountWizard.css
--- a/instantbird/content/accountWizard.css
+++ b/instantbird/content/accountWizard.css
@@ -1,7 +1,22 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-.top-protocol {
+.topProtocol {
   -moz-binding: url("chrome://instantbird/content/accountWizard.xml#topProtocol");
 }
+
+.existingAccount {
+  -moz-binding: url("chrome://instantbird/content/accountWizard.xml#existingAccount");
+}
+
+.newAccount {
+  -moz-binding: url("chrome://instantbird/content/accountWizard.xml#newAccount");
+}
+
+richlistitem[checked="false"] .showChecked,
+richlistitem[checked="true"] .hideChecked,
+.hiddenSource
+{
+  display: none;
+}
diff --git a/instantbird/content/accountWizard.js b/instantbird/content/accountWizard.js
--- a/instantbird/content/accountWizard.js
+++ b/instantbird/content/accountWizard.js
@@ -3,208 +3,422 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
 Cu.import("resource:///modules/imServices.jsm");
 
 const PREF_EXTENSIONS_GETMOREPROTOCOLSURL = "extensions.getMoreProtocolsURL";
 
 var accountWizard = {
+  // As accounts are configured, the settings for each will be kept in a array
+  // and push/pop will be performed as necessary during Next/Back commands.
+  accounts: [],
   onload: function aw_onload() {
+    let wizard = document.getElementById("accountWizard");
+    let bundle = document.getElementById("accountWizardBundle");
+    wizard.getPageById("accounttoplist").newaccount = true;
+
+    Services.obs.addObserver(this, "prpl-quit", false);
+    window.addEventListener("unload", this.unload);
+
+    // The import wizard functionality may be turned off (hidden).
+    if (!Services.prefs.getBoolPref("messenger.importWizard.enabled")) {
+      this.hideWelcomePage();
+      wizard.goTo("accounttoplist");
+    }
+  },
+
+  unload: function aw_unload() {
+    Services.obs.removeObserver(accountWizard, "prpl-quit");
+  },
+
+  observe: function am_observe(aObject, aTopic, aData) {
+    if (aTopic == "prpl-quit") {
+      // libpurple is being uninitialized. We can't create any new
+      // account so keeping this wizard open would be pointless, close it.
+      window.close();
+    }
+    else if (aTopic == "account-search-finished") {
+      this._searching = false;
+      let wizard = document.getElementById("accountWizard");
+      let bundle = document.getElementById("accountWizardBundle");
+      wizard.getButton("next").disabled = false;
+      let accountSummaryList = document.getElementById("accountSummaryList");
+      let searchImage = document.getElementById("accountSearchStatusImage");
+      let searchStatus = document.getElementById("accountImportStatus");
+      if (accountSummaryList.itemCount > 0) {
+        searchImage.className = "accountSearchSuccessful";
+        searchStatus.textContent =
+          bundle.getFormattedString("searchStatus.success.label", [this.searchCount]);
+      }
+      else {
+        searchImage.className = "accountSearchFailure";
+        searchStatus.textContent = bundle.getString("searchStatus.failure.label");
+        document.getElementById("accountSkipLabel").hidden = true;
+        wizard.getButton("extra1").hidden = true;
+        wizard.currentPage.next = "accounttoplist";
+      }
+    }
+    else if (aTopic == "existing-account-found") {
+      // Add a new item to the accountSummaryList with an existingAccount binding
+      let accountSummaryList = document.getElementById("accountSummaryList");
+      for (let i = 0; i < accountSummaryList.itemCount; ++i) {
+        let listedAccount = accountSummaryList.getItemAtIndex(i);
+        if (listedAccount.className !== "existingAccount")
+          return;
+
+        // Check if this account has been found already from a different client,
+        // and if so, only add an importer entry rather than a new item.
+        if (listedAccount.compareToAccount(aObject)) {
+          listedAccount.addAccount(aObject);
+
+          // TODO: Compare modifiedDates/set settings?
+          return;
+        }
+      }
+
+      // Avoid allowing the user to import an account that already exists.
+      let accProtocol = Services.core.getProtocolById(aObject.protocolId);
+      if (accProtocol.accountExists(aObject.name))
+        return;
+
+      let item = document.createElement("richlistitem");
+      item.className = "existingAccount";
+      accountSummaryList.appendChild(item);
+      item.build(aObject);
+      this.searchCount++;
+    }
+  },
+
+  showWelcomePage: function() {
+    let wizard = document.getElementById("accountWizard");
+
+    // Configure the extra1 button to act with "Skip" functionality.
+    let skipButton = wizard.getButton("extra1");
+    let nextButton = wizard.getButton("next");
+    skipButton.hidden = false;
+    if (!skipButton.label) {
+      let bundle = document.getElementById("accountWizardBundle");
+      skipButton.label = bundle.getString("skipButton.label");
+      skipButton.accessKey = bundle.getString("skipButton.accessKey");
+    }
+
+    // The import wizard functionality may be turned off (hidden).
+    if (Services.prefs.getBoolPref("messenger.importWizard.enabled"))
+      this.startImportSearch();
+  },
+
+  hideWelcomePage: function() {
+    let wizard = document.getElementById("accountWizard");
+    wizard.getButton('extra1').hidden = true;
+    wizard.getButton('next').disabled = false;
+  },
+
+  startImportSearch: function() {
+    // Protect against rapid Back/Next causing duplicate searching.
+    if (this._searching)
+      return;
+
+    this.clearSummaryList("existingAccount");
+
+    // Prepare the UI elements to show the search progress.
+    let bundle = document.getElementById("accountWizardBundle");
+    let status = document.getElementById("accountImportStatus");
+    status.textContent = bundle.getString("searchStatus.searching.label");
+    document.getElementById("accountWizard").getButton("next").disabled = true;
+    document.getElementById("accountSkipLabel").hidden = false;
+    document.getElementById("accountSearchStatusImage")
+            .className = "accountSearchSearching";
+
+    this.searchCount = 0;
+    this._searching = true;
+    Services.importers.findAccounts(this);
+  },
+
+  skipAccountImport: function() {
+    let wizard = document.getElementById("accountWizard");
+    let summaryList = document.getElementById("accountSummaryList");
+    // Remove the existing account summary entries.
+    this.clearSummaryList("existingAccount");
+    wizard.getPageById("accounttoplist").newaccount = true;
+    wizard.advance("accounttoplist");
+  },
+
+  selectProtocol: function aw_selectProtocol() {
+    let pageId = document.getElementById("accountWizard").currentPage.pageid;
+    let listId = pageId == "accounttoplist" ? "topprotolist" : "protolist";
+    let protoList = document.getElementById(listId);
+
+    // Create an object to store the values for this account.
+    this.accounts.pop();
+    this.accounts.push({
+      username: {},
+      options: [],
+      proto: Services.core.getProtocolById(protoList.selectedItem.value)
+    });
+    return true;
+  },
+
+  showTopProtocolPage: function() {
+    let wizard = document.getElementById("accountWizard");
     let topProtoList = document.getElementById("topprotolist");
-    let bundle = document.getElementById("topProtocolsBundle");
+
+    // Check if the page is being viewed after pressing 'Back' or not.
+    if (!wizard.currentPage.newaccount) {
+      // Some locales may have no top protocols. The top protocols page should
+      // be bypassed (rewound since no new account is being created).
+      if (topProtoList.itemCount < 2)
+        wizard.rewind();
+
+      let proto = this.getCurrentAccount().proto;
+      if (proto) {
+        // Select the protocol the user had chosen earlier (if in this list)
+        for (let i = 0; i < topProtoList.itemCount; ++i) {
+          let protoId = topProtoList.getItemAtIndex(i).value;
+          if (proto.id === protoId) {
+            topProtoList.selectedIndex = i;
+            break;
+          }
+        }
+      }
+      return true;
+    }
+    wizard.currentPage.newaccount = false;
+
+    // Push an empty account stack object for now. selectProtocol() will rewrite
+    // an update object on each protocol selection.
+    this.accounts.push({username: {}, options: []});
+
+    // Fill the top protocols list if it has not been filled already.
+    if (topProtoList.itemCount > 1) {
+      topProtoList.selectedIndex = -1;
+      return true;
+    }
+
+    let bundle = document.getElementById("accountWizardBundle");
     let topProtocols = bundle.getString("topProtocol.list").split(",");
-
     for each (let topProto in topProtocols) {
       let proto = Services.core.getProtocolById(topProto);
       if (proto == null)
         continue;
 
       let item = document.createElement("richlistitem");
-      item.className = "top-protocol";
+      item.className = "topProtocol";
       topProtoList.insertBefore(item, document.getElementById("otherListItem"));
       let desc = bundle.getString("topProtocol." + proto.id + ".description");
       item.build(proto, desc);
     }
 
-    if (topProtoList.itemCount < 2) {
-      document.getElementById("accountWizard")
-              .getPageById("accountwelcome").next = "accountprotocol";
+    // Avoid showing users an empty top protocols page.
+    if (topProtoList.itemCount < 2)
+      wizard.advance();
+
+    topProtoList.selectedIndex = -1;
+    return true;
+  },
+
+  rewindTopProtocolPage: function() {
+    // The top account on the stack should be removed, as we are either going
+    // to the welcome page or the summary page in reverse.
+    this.accounts.pop();
+  },
+
+  advanceTopProtocolPage: function() {
+    let wizard = document.getElementById("accountWizard");
+    let selectedProtocol = document.getElementById("topprotolist").selectedItem;
+    if (!selectedProtocol || selectedProtocol.id == "otherListItem")
+      wizard.getPageById("accounttoplist").next = "accountprotocol";
+    else {
+      accountWizard.selectProtocol();
+      wizard.getPageById("accounttoplist").next = "accountusername";
+    }
+    return true;
+  },
+
+  showProtocolPage: function() {
+    let protoList = document.getElementById("protolist");
+    if (protoList.itemCount > 0)
+      return true;
+
+    accountWizard.setGetMoreProtocols();
+    let protos = [];
+    for (let proto in accountWizard.getProtocols())
+      protos.push(proto);
+    protos.sort(function(a, b) a.name < b.name ? -1 : a.name > b.name ? 1 : 0);
+
+    for each (let proto in protos) {
+      let item = protoList.appendItem(proto.name, proto.id);
+      item.setAttribute("image", proto.iconBaseURI + "icon.png");
+      item.setAttribute("class", "listitem-iconic");
     }
 
-    topProtoList.selectedIndex = -1;
-
-    Services.obs.addObserver(this, "prpl-quit", false);
-    window.addEventListener("unload", this.unload);
-  },
-  unload: function aw_unload() {
-    Services.obs.removeObserver(accountWizard, "prpl-quit");
-  },
-  observe: function am_observe(aObject, aTopic, aData) {
-    if (aTopic == "prpl-quit") {
-      // libpurple is being uninitialized. We can't create any new
-      // account so keeping this wizard open would be pointless, close it.
-      window.close();
-    }
+    protoList.selectedIndex = 0;
+    return true;
   },
 
   getUsername: function aw_getUsername() {
     // If the first username textbox is empty, make sure we return an empty
     // string so that it blocks the 'next' button of the wizard.
     if (!this.userNameBoxes[0].value)
       return "";
 
     return this.userNameBoxes.reduce(function(prev, elt) prev + elt.value, "");
   },
 
   checkUsername: function aw_checkUsername() {
-    var wizard = document.getElementById("accountWizard");
-    var name = accountWizard.getUsername();
-    var duplicateWarning = document.getElementById("duplicateAccount");
+    let wizard = document.getElementById("accountWizard");
+    let name = accountWizard.getUsername();
+    let duplicateWarning = document.getElementById("duplicateAccount");
     if (!name) {
       wizard.canAdvance = false;
       duplicateWarning.hidden = true;
       return;
     }
 
-    var exists = accountWizard.proto.accountExists(name);
+    let exists = accountWizard.getCurrentAccount().proto.accountExists(name);
     wizard.canAdvance = !exists;
     duplicateWarning.hidden = !exists;
   },
 
-  selectProtocol: function aw_selectProtocol() {
-    // A fix for users wanting to return to the list they previously viewed.
-    var pageId = document.getElementById("accountWizard").currentPage.pageid;
-    document.getElementById("accountusername").previous = pageId;
-
-    var listId = pageId == "accounttoplist" ? "topprotolist" : "protolist";
-    var protoList = document.getElementById(listId);
-    this.proto = Services.core.getProtocolById(protoList.selectedItem.value);
-
-    return true;
-  },
-
   insertUsernameField: function aw_insertUsernameField(aName, aLabel, aParent,
                                                        aDefaultValue) {
-    var hbox = document.createElement("hbox");
+    let hbox = document.createElement("hbox");
     hbox.setAttribute("id", aName + "-hbox");
     hbox.setAttribute("align", "baseline");
     hbox.setAttribute("equalsize", "always");
 
-    var label = document.createElement("label");
+    let label = document.createElement("label");
     label.setAttribute("value", aLabel);
     label.setAttribute("control", aName);
     label.setAttribute("id", aName + "-label");
     hbox.appendChild(label);
 
-    var textbox = document.createElement("textbox");
+    let textbox = document.createElement("textbox");
     textbox.setAttribute("id", aName);
     textbox.setAttribute("flex", 1);
     if (aDefaultValue)
       textbox.setAttribute("value", aDefaultValue);
     textbox.addEventListener("input", accountWizard.checkUsername);
     hbox.appendChild(textbox);
 
     aParent.appendChild(hbox);
     return textbox;
   },
 
   showUsernamePage: function aw_showUsernamePage() {
-    var proto = this.proto.id;
-    if ("userNameBoxes" in this && this.userNameProto == proto) {
-      this.checkUsername();
-      return;
-    }
-
-    var bundle = document.getElementById("accountsBundle");
-    var usernameInfo;
-    var emptyText = this.proto.usernameEmptyText;
+    let proto = this.getCurrentAccount().proto;
+    let bundle = document.getElementById("accountsBundle");
+    let usernameInfo;
+    let emptyText = proto.usernameEmptyText;
     if (emptyText) {
       usernameInfo =
         bundle.getFormattedString("accountUsernameInfoWithDescription",
-                                  [emptyText, this.proto.name]);
+                                  [emptyText, proto.name]);
     }
     else {
       usernameInfo =
-        bundle.getFormattedString("accountUsernameInfo", [this.proto.name]);
+        bundle.getFormattedString("accountUsernameInfo", [proto.name]);
     }
     document.getElementById("usernameInfo").textContent = usernameInfo;
 
-    var vbox = document.getElementById("userNameBox");
+    let vbox = document.getElementById("userNameBox");
     // remove anything that may be there for another protocol
-    var child;
+    let child;
     while ((child = vbox.firstChild))
       vbox.removeChild(child);
 
-    var splits = [];
+    let splits = [];
     for (let split in this.getProtoUserSplits())
       splits.push(split);
 
-    var label = bundle.getString("accountUsername");
+    let label = bundle.getString("accountUsername");
     this.userNameBoxes = [this.insertUsernameField("name", label, vbox)];
     this.userNameBoxes[0].emptyText = emptyText;
 
     for (let i = 0; i < splits.length; ++i) {
       this.userNameBoxes.push({value: splits[i].separator});
       label = bundle.getFormattedString("accountColon", [splits[i].label]);
       let defaultVal = splits[i].defaultValue;
       this.userNameBoxes.push(this.insertUsernameField("username-split-" + i,
                                                        label, vbox,
                                                        defaultVal));
     }
+
+    // Restore the username values if previously set.
+    let boxValues = this.getCurrentAccount().username.sections;
+    if (boxValues && boxValues.length) {
+      for (let i = 0; i < this.userNameBoxes.length; ++i)
+        this.userNameBoxes[i].value = boxValues[i];
+    }
+
     this.userNameBoxes[0].focus();
-    this.userNameProto = proto;
+    this.userNameProto = proto.id;
     this.checkUsername();
   },
 
   hideUsernamePage: function aw_hideUsernamePage() {
     document.getElementById("accountWizard").canAdvance = true;
-    var next = "account" +
-      (this.proto.noPassword ? "advanced" : "password");
+    let next = "account" +
+      (this.getCurrentAccount().proto.noPassword ? "advanced" : "password");
     document.getElementById("accountusername").next = next;
   },
 
+  advanceUsernamePage: function aw_advanceUsernamePage() {
+    // Store the username in the accounts stack. We want to be able to retrieve
+    // both the complete name and the individual textbox values (if applicable)
+    this.getCurrentAccount().username.value = this.getUsername();
+    this.getCurrentAccount().username.sections = [];
+    for each (let box in this.userNameBoxes)
+      this.getCurrentAccount().username.sections.push(box.value);
+  },
+
+  showPasswordPage: function aw_showPasswordPage() {
+    let password = this.getCurrentAccount().password;
+    document.getElementById("password").value = (password ? password : "");
+  },
+
+  advancePasswordPage: function aw_advancePasswordPage() {
+    this.getCurrentAccount().password = this.getValue("password");
+  },
+
   showAdvanced: function aw_showAdvanced() {
-    // ensure we don't destroy user data if it's not necessary
-    var id = this.proto.id;
-    if ("protoSpecOptId" in this && this.protoSpecOptId == id)
-      return;
-    this.protoSpecOptId = id;
-
+    let proto = this.getCurrentAccount().proto;
 /* FIXME
     document.getElementById("newMailNotification").hidden =
       !this.proto.newMailNotification;
 */
     this.populateProtoSpecificBox();
 
-    let proxyVisible = this.proto.usePurpleProxy;
+    let proxyVisible = proto.usePurpleProxy;
     if (proxyVisible) {
-      this.proxy = Components.classes["@instantbird.org/purple/proxyinfo;1"]
-                             .createInstance(Ci.purpleIProxyInfo);
-      this.proxy.type = Ci.purpleIProxyInfo.useGlobal;
+      this.getCurrentAccount().proxy = Cc["@instantbird.org/purple/proxyinfo;1"]
+                                         .createInstance(Ci.purpleIProxyInfo);
+      this.getCurrentAccount().proxy.type = Ci.purpleIProxyInfo.useGlobal;
       this.displayProxyDescription();
     }
     document.getElementById("proxyGroupbox").hidden = !proxyVisible;
 
-    let alias = document.getElementById("alias");
-    alias.focus();
+    let alias = this.getCurrentAccount().alias;
+    let aliasBox = document.getElementById("alias");
+    aliasBox.value = (alias ? alias : "");
+    aliasBox.focus();
   },
 
   displayProxyDescription: function aw_displayProxyDescription() {
-    var type = this.proxy.type;
-    var bundle = document.getElementById("proxiesBundle");
-    var proxy;
-    var result;
+    let type = this.getCurrentAccount().proxy.type;
+    let bundle = document.getElementById("proxiesBundle");
+    let proxy;
+    let result;
     if (type == Ci.purpleIProxyInfo.useGlobal) {
       proxy = Cc["@instantbird.org/libpurple/core;1"]
-              .getService(Ci.purpleICoreService).globalProxy;
+                .getService(Ci.purpleICoreService).globalProxy;
       type = proxy.type;
     }
     else
-      proxy = this.proxy;
+      proxy = this.getCurrentAccount().proxy;
 
     if (type == Ci.purpleIProxyInfo.noProxy)
       result = bundle.getString("proxies.directConnection");
 
     if (type == Ci.purpleIProxyInfo.useEnvVar)
       result = bundle.getString("proxies.useEnvironment");
 
     if (!result) {
@@ -226,282 +440,348 @@ var accountWizard = {
 
       result += proxy.host + ":" + proxy.port;
     }
 
     document.getElementById("proxyDescription").textContent = result;
   },
 
   createTextbox: function aw_createTextbox(aType, aValue, aLabel, aName) {
-    var box = document.createElement("hbox");
+    let box = document.createElement("hbox");
     box.setAttribute("align", "baseline");
     box.setAttribute("equalsize", "always");
 
-    var label = document.createElement("label");
+    let label = document.createElement("label");
     label.setAttribute("value", aLabel);
     label.setAttribute("control", aName);
     box.appendChild(label);
 
-    var textbox = document.createElement("textbox");
+    let textbox = document.createElement("textbox");
     if (aType)
       textbox.setAttribute("type", aType);
     textbox.setAttribute("value", aValue);
     textbox.setAttribute("id", aName);
     textbox.setAttribute("flex", "1");
 
     box.appendChild(textbox);
     return box;
   },
 
   createMenulist: function aw_createMenulist(aList, aLabel, aName) {
-    var box = document.createElement("hbox");
+    let box = document.createElement("hbox");
     box.setAttribute("align", "baseline");
 
-    var label = document.createElement("label");
+    let label = document.createElement("label");
     label.setAttribute("value", aLabel);
     label.setAttribute("control", aName);
     box.appendChild(label);
 
     aList.QueryInterface(Ci.nsISimpleEnumerator);
-    var menulist = document.createElement("menulist");
+    let menulist = document.createElement("menulist");
     menulist.setAttribute("id", aName);
-    var popup = menulist.appendChild(document.createElement("menupopup"));
+    let popup = menulist.appendChild(document.createElement("menupopup"));
     while (aList.hasMoreElements()) {
       let elt = aList.getNext();
       let item = document.createElement("menuitem");
       item.setAttribute("label", elt.name);
       item.setAttribute("value", elt.value);
       popup.appendChild(item);
     }
     box.appendChild(menulist);
     return box;
   },
 
   populateProtoSpecificBox: function aw_populate() {
-    var id = this.proto.id;
-    var box = document.getElementById("protoSpecific");
-    var child;
+    let accObj = this.getCurrentAccount();
+    let [proto, id, options] = [accObj.proto, accObj.proto.id, accObj.options];
+    let box = document.getElementById("protoSpecific");
+    let child;
     while ((child = box.firstChild))
       box.removeChild(child);
-    var visible = false;
-    for (let opt in this.getProtoOptions()) {
-      var text = opt.label;
-      var name = id + "-" + opt.name;
+    let visible = false;
+    for (let opt in this.getProtoOptions(proto.id)) {
+      let [text, name] = [opt.label, id + "-" + opt.name];
+
+      // Recall set settings in the account stack object.
+      let savedVal;
+      for each (let savedOption in options) {
+        if (savedOption.name === opt.name)
+          savedVal = savedOption.value;
+      }
+
       switch (opt.type) {
       case opt.typeBool:
-        var chk = document.createElement("checkbox");
+        let chk = document.createElement("checkbox");
         chk.setAttribute("label", text);
         chk.setAttribute("id", name);
-        if (opt.getBool())
-          chk.setAttribute("checked", "true");
+        let chkVal = (savedVal ? savedVal : (opt.getBool() ? "true" : "false"));
+        chk.setAttribute("checked", chkVal);
         box.appendChild(chk);
         break;
       case opt.typeInt:
-        box.appendChild(this.createTextbox("number", opt.getInt(),
-                                           text, name));
+        let intVal = (savedVal ? savedVal : opt.getInt());
+        box.appendChild(this.createTextbox("number", intVal, text, name));
         break;
       case opt.typeString:
-        box.appendChild(this.createTextbox(null, opt.getString(), text, name));
+        let stringVal = (savedVal ? savedVal : opt.getString());
+        box.appendChild(this.createTextbox(null, stringVal, text, name));
         break;
       case opt.typeList:
         box.appendChild(this.createMenulist(opt.getList(), text, name));
-        document.getElementById(name).value = opt.getListDefault();
+        let listVal = (savedVal ? savedVal : opt.getListDefault());
+        document.getElementById(name).value = listVal;
         break;
       default:
         throw "unknown preference type " + opt.type;
       }
       visible = true;
     }
     document.getElementById("protoSpecificGroupbox").hidden = !visible;
     if (visible) {
-      var bundle = document.getElementById("accountsBundle");
+      let bundle = document.getElementById("accountsBundle");
       document.getElementById("protoSpecificCaption").label =
-        bundle.getFormattedString("protoOptions", [this.proto.name]);
+        bundle.getFormattedString("protoOptions", [proto.name]);
     }
   },
 
-  createSummaryRow: function aw_createSummaryRow(aLabel, aValue) {
-    var row = document.createElement("row");
-    row.setAttribute("align", "baseline");
-
-    var label = document.createElement("label");
-    label.setAttribute("class", "header");
-    if (aLabel.length > 20) {
-      aLabel = aLabel.substring(0, 20);
-      aLabel += "â€¦";
-    }
-    label.setAttribute("value", aLabel);
-    row.appendChild(label);
-
-    var textbox = document.createElement("textbox");
-    textbox.setAttribute("value", aValue);
-    textbox.setAttribute("class", "plain");
-    textbox.setAttribute("readonly", true);
-    row.appendChild(textbox);
-
-    return row;
-  },
-
-  showSummary: function aw_showSummary() {
-    var rows = document.getElementById("summaryRows");
-    var bundle = document.getElementById("accountsBundle");
-    var child;
-    while ((child = rows.firstChild))
-      rows.removeChild(child);
-
-    var label = bundle.getString("accountProtocol");
-    rows.appendChild(this.createSummaryRow(label, this.proto.name));
-    this.username = this.getUsername();
-    label = bundle.getString("accountUsername");
-    rows.appendChild(this.createSummaryRow(label, this.username));
-    if (!this.proto.noPassword) {
-      this.password = this.getValue("password");
-      if (this.password) {
-        label = document.getElementById("passwordLabel").value;
-        var pass = "";
-        for (let i = 0; i < this.password.length; ++i)
-          pass += "*";
-        rows.appendChild(this.createSummaryRow(label, pass));
-      }
-    }
-    this.alias = this.getValue("alias");
-    if (this.alias) {
-      label = document.getElementById("aliasLabel").value;
-      rows.appendChild(this.createSummaryRow(label, this.alias));
-    }
-
-/* FIXME
-    if (this.proto.newMailNotification)
-      rows.appendChild(this.createSummaryRow("Notify of new mails:",
-                                             this.getValue("newMailNotification")));
-*/
-
-    var id = this.proto.id;
-    this.prefs = [ ];
-    for (let opt in this.getProtoOptions()) {
+  advanceOptionsPage: function() {
+    let accountObj = this.getCurrentAccount();
+    accountObj.alias = this.getValue("alias");
+    accountObj.options = [];
+    for (let opt in this.getProtoOptions(accountObj.proto.id)) {
       let name = opt.name;
-      let eltName = id + "-" + name;
+      let eltName = accountObj.proto.id + "-" + name;
       let val = this.getValue(eltName);
       // The value will be undefined if the proto specific groupbox has never been opened
       if (val === undefined)
         continue;
       switch (opt.type) {
       case opt.typeBool:
         if (val != opt.getBool())
-          this.prefs.push({opt: opt, name: name, value: !!val});
+          accountObj.options.push({opt: opt, name: name, value: !!val});
         break;
       case opt.typeInt:
         if (val != opt.getInt())
-          this.prefs.push({opt: opt, name: name, value: val});
+          accountObj.options.push({opt: opt, name: name, value: val});
         break;
       case opt.typeString:
         if (val != opt.getString())
-          this.prefs.push({opt: opt, name: name, value: val});
+          accountObj.options.push({opt: opt, name: name, value: val});
         break;
       case opt.typeList:
         if (val != opt.getListDefault())
-          this.prefs.push({opt: opt, name: name, value: val});
+          accountObj.options.push({opt: opt, name: name, value: val});
         break;
       default:
         throw "unknown preference type " + opt.type;
       }
     }
+  },
 
-    for (let i = 0; i < this.prefs.length; ++i) {
-      let opt = this.prefs[i];
-      let label = bundle.getFormattedString("accountColon", [opt.opt.label]);
-      rows.appendChild(this.createSummaryRow(label, opt.value));
+  showSummary: function aw_showSummary() {
+    let wizard = document.getElementById("accountWizard");
+    let bundle = document.getElementById("accountWizardBundle");
+    let summaryList = document.getElementById("accountSummaryList");
+
+    // Configure the extra2 button for "Add another account".
+    let addButton = wizard.getButton("extra2");
+    addButton.hidden = false;
+    if (!addButton.label) {
+      addButton.label = bundle.getString("addButton.label");
+      addButton.accessKey = bundle.getString("addButton.accessKey");
+    }
+
+    // Remove any new account summary entries.
+    this.clearSummaryList("newAccount");
+
+    // Add each new account item to the summary list.
+    for each (let accountObj in this.accounts) {
+      let item = document.createElement("richlistitem");
+      item.className = "newAccount";
+      summaryList.appendChild(item);
+      item.build(accountObj);
     }
   },
 
-  createAccount: function aw_createAccount() {
-    var acc = Services.accounts.createAccount(this.username, this.proto.id);
-    if (!this.proto.noPassword && this.password)
-      acc.password = this.password;
-    if (this.alias)
-      acc.alias = this.alias;
-    //FIXME: newMailNotification
+  hideSummary: function() {
+    document.getElementById("accountWizard").getButton("extra2").hidden = true;
+  },
 
-    for (let i = 0; i < this.prefs.length; ++i) {
-      let option = this.prefs[i];
-      let opt = option.opt;
-      switch(opt.type) {
-      case opt.typeBool:
-        acc.setBool(option.name, option.value);
-        break;
-      case opt.typeInt:
-        acc.setInt(option.name, option.value);
-        break;
-      case opt.typeString:
-      case opt.typeList:
-        acc.setString(option.name, option.value);
-        break;
-      default:
-        throw "unknown type";
+  addAnotherAccount: function() {
+    // Users may add multiple accounts through this wizard. The extra2 button
+    // calls this method, which will prepare the wizard to create another account.
+    let wizard = document.getElementById("accountWizard");
+    wizard.getPageById("accounttoplist").newaccount = true;
+    wizard.advance("accounttoplist");
+  },
+
+  clearSummaryList: function(aItemClass) {
+    let summaryList = document.getElementById("accountSummaryList");
+    for (let i = (summaryList.itemCount - 1); i >= 0 ; --i) {
+      let entry = summaryList.getItemAtIndex(i);
+      if (aItemClass && entry.className === aItemClass)
+        summaryList.removeItemAt(i);
+      else if (!aItemClass)
+        summaryList.removeItemAt(i);
+    }
+  },
+
+  createAccounts: function aw_createAccounts() {
+    let accountList = document.getElementById("accountSummaryList");
+    for (let i = 0; i < accountList.itemCount; ++i) {
+      let entry = accountList.getItemAtIndex(i);
+      // If an entry is not checked, it should not be created.
+      if (!entry.checked)
+        continue;
+
+      if (entry.className == "existingAccount") {
+        let existingAcc = entry.account[entry.getSelectedImporterId()];
+        let protocol = Services.core.getProtocolById(existingAcc.protocolId);
+        let acc = Services.accounts.createAccount(entry.getAttribute("username"),
+                                                  protocol.id);
+        if (!protocol.noPassword && existingAcc.password)
+          acc.password = existingAcc.password;
+        if (existingAcc.alias)
+          acc.alias = existingAcc.alias;
+        let changedOptions = this.getIter(existingAcc.getOptions());
+        for (let option in changedOptions) {
+          switch(option.type) {
+          case option.typeBool:
+            acc.setBool(option.name, option.getBool());
+            break;
+          case option.typeInt:
+            acc.setInt(option.name, option.getInt());
+            break;
+          case option.typeString:
+          case option.typeList:
+            acc.setString(option.name, option.getString());
+            break;
+          default:
+            throw "accountWizard.createAccounts() setting option of unknown type.";
+          }
+        }
+
+        let autologin = entry.autologin;
+        acc.autoLogin = autologin;
+
+        //TODO: Proxy information from importer?
+        acc.save();
+
+        try {
+          if (autologin)
+            acc.connect();
+        } catch (e) {
+          // If the connection fails (for example if we are currently in
+          // offline mode), we still want to close the account wizard
+        }
+
+        if (window.opener) {
+          let am = window.opener.gAccountManager;
+          if (am)
+            am.selectAccount(acc.id);
+        }
+
+        // Add this new account to the queue of accounts needing data import.
+        Services.importers.queueAccount(acc.id, entry.getSelectedImporterId());
+      }
+      else if (entry.className == "newAccount") {
+        let acc = Services.accounts.createAccount(entry.getAttribute("username"),
+                                                  entry.protocolId);
+        let protocol = Services.core.getProtocolById(entry.protocolId);
+        if (!protocol.noPassword && entry.password)
+          acc.password = entry.password;
+        if (entry.alias)
+          acc.alias = entry.alias;
+        for each (let option in entry.options) {
+          let opt = option.opt;
+          switch(opt.type) {
+          case opt.typeBool:
+            acc.setBool(option.name, option.value);
+            break;
+          case opt.typeInt:
+            acc.setInt(option.name, option.value);
+            break;
+          case opt.typeString:
+          case opt.typeList:
+            acc.setString(option.name, option.value);
+            break;
+          default:
+            throw "accountWizard.createAccounts() setting option of unknown type.";
+          }
+        }
+
+        let autologin = entry.autologin;
+        acc.autoLogin = autologin;
+
+        if (protocol.usePurpleProxy)
+          acc.proxyInfo = entry.proxy;
+
+        acc.save();
+
+        try {
+          if (autologin)
+            acc.connect();
+        } catch (e) {
+          // If the connection fails (for example if we are currently in
+          // offline mode), we still want to close the account wizard
+        }
+
+        if (window.opener) {
+          let am = window.opener.gAccountManager;
+          if (am)
+            am.selectAccount(acc.id);
+        }
       }
     }
-    var autologin = this.getValue("connectNow");
-    acc.autoLogin = autologin;
 
-    if (this.proto.usePurpleProxy)
-      acc.proxyInfo = this.proxy;
-
-    acc.save();
-
-    try {
-      if (autologin)
-        acc.connect();
-    } catch (e) {
-      // If the connection fails (for example if we are currently in
-      // offline mode), we still want to close the account wizard
-    }
-
-    if (window.opener) {
-      var am = window.opener.gAccountManager;
-      if (am)
-        am.selectAccount(acc.id);
-    }
-
+    // This initiates the data importing process. Data will be imported in the
+    // background for the user during idle. The process will continue if the
+    // program is restarted.
+    if (Services.prefs.getBoolPref("messenger.importWizard.enabled"))
+      Services.importers.initImporters();
     return true;
   },
 
   getValue: function aw_getValue(aId) {
-    var elt = document.getElementById(aId);
+    let elt = document.getElementById(aId);
     if ("checked" in elt)
       return elt.checked;
     if ("value" in elt)
       return elt.value;
     // If the groupbox has never been opened, the binding isn't attached
     // so the attributes don't exist. The calling code in showSummary
     // has a special handling of the undefined value for this case.
     return undefined;
   },
 
   getIter: function(aEnumerator) {
     while (aEnumerator.hasMoreElements())
       yield aEnumerator.getNext();
   },
   getProtocols: function aw_getProtocols()
     this.getIter(Services.core.getProtocols()),
-  getProtoOptions: function aw_getProtoOptions()
-    this.getIter(this.proto.getOptions()),
+  getProtoOptions: function aw_getProtoOptions(aProtocolId)
+    this.getIter(Services.core.getProtocolById(aProtocolId).getOptions()),
   getProtoUserSplits: function aw_getProtoUserSplits()
-    this.getIter(this.proto.getUsernameSplit()),
+    this.getIter(this.getCurrentAccount().proto.getUsernameSplit()),
+
+  getCurrentAccount: function aw_getCurrentAccount()
+    this.accounts[this.accounts.length - 1],
 
   onGroupboxKeypress: function aw_onGroupboxKeypress(aEvent) {
-    var target = aEvent.target;
-    var code = aEvent.charCode || aEvent.keyCode;
+    let target = aEvent.target;
+    let code = aEvent.charCode || aEvent.keyCode;
     if (code == KeyEvent.DOM_VK_SPACE ||
         (code == KeyEvent.DOM_VK_LEFT && !target.hasAttribute("closed")) ||
         (code == KeyEvent.DOM_VK_RIGHT && target.hasAttribute("closed")))
         this.toggleGroupbox(target.id);
   },
 
   toggleGroupbox: function aw_toggleGroupbox(id) {
-    var elt = document.getElementById(id);
+    let elt = document.getElementById(id);
     if (elt.hasAttribute("closed")) {
       elt.removeAttribute("closed");
       if (elt.flexWhenOpened)
         elt.flex = elt.flexWhenOpened;
     }
     else {
       elt.setAttribute("closed", "true");
       if (elt.flex) {
@@ -513,74 +793,35 @@ var accountWizard = {
 
   openProxySettings: function aw_openProxySettings() {
     window.openDialog("chrome://instantbird/content/proxies.xul", "",
                       "chrome,modal,titlebar,centerscreen",
                       this);
     this.displayProxyDescription();
   },
 
-  /* Check for correctness and set URL for the "Get more protocols..."-link
-   *  Stripped down code from preferences/themes.js
-   */
-  setGetMoreProtocols: function (){
+  // Check for correctness and set URL for the "Get more protocols..."-link
+  // Stripped down code from preferences/themes.js
+  setGetMoreProtocols: function() {
     let prefURL = PREF_EXTENSIONS_GETMOREPROTOCOLSURL;
-    var getMore = document.getElementById("getMoreProtocols");
-    var showGetMore = false;
+    let getMore = document.getElementById("getMoreProtocols");
+    let showGetMore = false;
     const nsIPrefBranch2 = Components.interfaces.nsIPrefBranch2;
 
     if (Services.prefs.getPrefType(prefURL) != nsIPrefBranch2.PREF_INVALID) {
       try {
-        var getMoreURL = Components.classes["@mozilla.org/toolkit/URLFormatterService;1"]
-                                   .getService(Components.interfaces.nsIURLFormatter)
-                                   .formatURLPref(prefURL);
+        let getMoreURL = Cc["@mozilla.org/toolkit/URLFormatterService;1"]
+                           .getService(Components.interfaces.nsIURLFormatter)
+                           .formatURLPref(prefURL);
         getMore.setAttribute("getMoreURL", getMoreURL);
         showGetMore = getMoreURL != "about:blank";
       }
       catch (e) { }
     }
     getMore.hidden = !showGetMore;
   },
 
-  openURL: function (aURL) {
-    Components.classes["@mozilla.org/uriloader/external-protocol-service;1"]
-              .getService(Components.interfaces.nsIExternalProtocolService)
-              .loadUrl(Services.io.newURI(aURL, null, null));
-  },
-
-  advanceTopProtocolPage: function() {
-    let selectedProtocol = document.getElementById("topprotolist").selectedItem;
-    if (!selectedProtocol || selectedProtocol.id == "otherListItem")
-      return true;
-    accountWizard.selectProtocol();
-    document.getElementById("accountWizard").goTo("accountusername");
-    return false;
-  },
-
-  rewindFromUsernamePage: function() {
-    let wizard = document.getElementById("accountWizard");
-    let previousPage = wizard.getPageById("accountusername").previous;
-    if (previousPage == "accountprotocol")
-      return true;
-    wizard.goTo(previousPage);
-    return false;
-  },
-
-  showProtocolPage: function() {
-    let protoList = document.getElementById("protolist");
-    if (protoList.itemCount > 0)
-      return;
-
-    accountWizard.setGetMoreProtocols();
-    let protos = [];
-    for (let proto in accountWizard.getProtocols())
-      protos.push(proto);
-    protos.sort(function(a, b) a.name < b.name ? -1 : a.name > b.name ? 1 : 0);
-
-    protos.forEach(function(proto) {
-      let item = protoList.appendItem(proto.name, proto.id);
-      item.setAttribute("image", proto.iconBaseURI + "icon.png");
-      item.setAttribute("class", "listitem-iconic");
-    });
-
-    protoList.selectedIndex = 0;
+  openURL: function(aURL) {
+    let urlUri = Services.io.newURI(aURL, null, null);
+    Cc["@mozilla.org/uriloader/external-protocol-service;1"]
+      .getService(Ci.nsIExternalProtocolService).loadUrl(urlUri);
   }
 };
diff --git a/instantbird/content/accountWizard.xml b/instantbird/content/accountWizard.xml
--- a/instantbird/content/accountWizard.xml
+++ b/instantbird/content/accountWizard.xml
@@ -1,42 +1,248 @@
 <?xml version="1.0"?>
 <!-- This Source Code Form is subject to the terms of the Mozilla Public
    - License, v. 2.0. If a copy of the MPL was not distributed with this
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <!DOCTYPE bindings [
-  <!ENTITY % accountsDTD SYSTEM "chrome://instantbird/locale/accountWizard.dtd">
+  <!ENTITY % accountWizardDTD SYSTEM "chrome://instantbird/locale/accountWizard.dtd">
+  %accountWizardDTD;
+  <!ENTITY % accountsDTD SYSTEM "chrome://instantbird/locale/accounts.dtd">
   %accountsDTD;
 ]>
 
 <bindings id="accountWizardBindings"
           xmlns="http://www.mozilla.org/xbl"
           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
           xmlns:xbl="http://www.mozilla.org/xbl">
 
   <binding id="topProtocol" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
     <content align="center">
-     <xul:image xbl:inherits="src=prplicon" class="top-proto-icon"/>
-     <xul:vbox>
-       <xul:label xbl:inherits="value=name" class="top-proto-name"/>
-       <xul:description xbl:inherits="value=description" class="top-proto-description"/>
-     </xul:vbox>
+      <xul:image xbl:inherits="src=prplicon" class="topProtoIcon"/>
+      <xul:vbox>
+        <xul:label xbl:inherits="value=name" class="topProtoName"/>
+        <xul:description xbl:inherits="value=description" class="topProtoDescription"/>
+      </xul:vbox>
     </content>
     <implementation>
-     <method name="build">
-      <parameter name="aProtocol"/>
-      <parameter name="aDescription"/>
-      <body>
-      <![CDATA[
-        this.setAttribute("name", aProtocol.name);
-        this.setAttribute("description", aDescription);
-        this.setAttribute("prplicon", aProtocol.iconBaseURI + "icon32.png");
-        this.value = aProtocol.id;
-      ]]>
-      </body>
-     </method>
-     <!-- override the default accessible name.
-          This is also used for typeahead selection. -->
-     <property name="label" onget="return this.getAttribute('name');"/>
+      <method name="build">
+        <parameter name="aProtocol"/>
+        <parameter name="aDescription"/>
+        <body>
+        <![CDATA[
+          this.setAttribute("name", aProtocol.name);
+          this.setAttribute("description", aDescription);
+          this.setAttribute("prplicon", aProtocol.iconBaseURI + "icon32.png");
+          this.value = aProtocol.id;
+        ]]>
+        </body>
+      </method>
+      <!-- override the default accessible name.
+           This is also used for typeahead selection. -->
+      <property name="label" onget="return this.getAttribute('name');"/>
     </implementation>
   </binding>
+
+  <binding id="existingAccount" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
+    <content>
+      <xul:vbox flex="1">
+        <xul:hbox flex="1" align="center">
+          <xul:vbox>
+            <xul:checkbox anonid="accountSelected"
+                          xbl:inherits="checked" class="summaryCheckbox"
+                          oncommand="document.getBindingParent(this).updateChecked();"/>
+          </xul:vbox>
+          <xul:vbox>
+            <xul:image xbl:inherits="src=prplicon" class="summaryIcon"/>
+          </xul:vbox>
+          <xul:vbox flex="1">
+            <xul:hbox align="baseline">
+              <xul:description xbl:inherits="value=username" class="summaryName"/>
+              <xul:separator flex="1" hidden="true"/>
+              <xul:checkbox label="&accountSummary.connectAutomatically.label;"
+                            dir="reverse" class="summaryAutologinCheckbox" hidden="true"
+                            anonid="autologin"/>
+            </xul:hbox>
+            <xul:hbox align="center" class="textGroup">
+              <xul:label class="showChecked" value="&accountExisting.doImport.label;"/>
+              <xul:label class="hideChecked" value="&accountExisting.noImport.label;"/>
+              <xul:label class="summaryImporterText showChecked" anonid="singleClient"/>
+              <xul:menulist class="summaryImporterList hiddenSource showChecked"
+                            anonid="availableImporters"/>
+            </xul:hbox>
+          </xul:vbox>
+        </xul:hbox>
+      </xul:vbox>
+    </content>
+    <implementation>
+      <property name="autologin"
+                onget="return document.getAnonymousElementByAttribute(this,
+                                                  'anonid',
+                                                  'autologin').checked;"/>
+      <property name="checked"
+                onget="return document.getAnonymousElementByAttribute(this,
+                                                  'anonid',
+                                                  'accountSelected').checked;"/>
+      <method name="build">
+        <parameter name="aExistingAccount"/>
+        <body>
+        <![CDATA[
+          this.setAttribute("username", aExistingAccount.name);
+          this.setAttribute("checked", true);
+          this.addAccount(aExistingAccount);
+
+          document.getAnonymousElementByAttribute(this, "anonid", "autologin")
+                  .checked = aExistingAccount.autoLogin;
+
+          let protocol = Services.core.getProtocolById(aExistingAccount.protocolId);
+          if (protocol)
+            this.setAttribute("prplicon", protocol.iconBaseURI + "icon32.png");
+          else
+            Cu.reportError("Attempted to build existingAccount binding with null protocol!");
+        ]]>
+        </body>
+      </method>
+      <method name="compareToAccount">
+        <parameter name="aExistingAccount"/>
+        <body>
+        <![CDATA[
+          let account = this.account[this.getSelectedImporterId()];
+          return (account.name == aExistingAccount.name &&
+                  account.protocolId == aExistingAccount.protocolId);
+        ]]>
+        </body>
+      </method>
+      <method name="addAccount">
+        <parameter name="aExistingAccount"/>
+        <body>
+        <![CDATA[
+          // Locate the importer from its ID to retrieve the display name.
+          let importerId = aExistingAccount.importerId;
+          let importer = Services.importers.getImporterById(importerId);
+
+          // If this is the first importer to find this account, the label needs
+          // to be set as well.
+          let label = document.getAnonymousElementByAttribute(this, "anonid",
+                                                              "singleClient");
+          if (!label.value)
+            label.setAttribute("value", importer.name);
+
+          // Add a menulist entry (regardless if it is shown yet)
+          let importers = document.getAnonymousElementByAttribute(this, "anonid",
+                                                                  "availableImporters");
+          let newitem = importers.appendItem(importer.name);
+          newitem.value = importerId;
+
+          // Store this account as well.
+          if (!this.account)
+            this.account = {};
+          this.account[importerId] = aExistingAccount;
+
+          if (importers.itemCount > 1) {
+            label.className += " hiddenSource";
+            importers.className = "summaryImporterList showChecked";
+          }
+
+          if (!importers.selectedItem)
+            importers.selectedIndex = 0;
+        ]]>
+        </body>
+      </method>
+      <method name="updateChecked">
+        <body>
+        <![CDATA[
+          let checkbox = document.getAnonymousElementByAttribute(this, "anonid",
+                                                                 "accountSelected");
+          this.setAttribute("checked", checkbox.checked);
+        ]]>
+        </body>
+      </method>
+      <method name="getSelectedImporterId">
+        <body>
+        <![CDATA[
+          let importers = document.getAnonymousElementByAttribute(this, "anonid",
+                                                                  "availableImporters");
+          return importers.selectedItem.value;
+        ]]>
+        </body>
+      </method>
+    </implementation>
+  </binding>
+
+  <binding id="newAccount" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
+    <content align="top">
+      <xul:vbox flex="1">
+        <xul:hbox flex="1" align="center">
+          <xul:vbox>
+            <xul:checkbox anonid="accountSelected"
+                          xbl:inherits="checked" class="summaryCheckbox"
+                          oncommand="document.getBindingParent(this).updateChecked();"/>
+          </xul:vbox>
+          <xul:vbox>
+            <xul:image xbl:inherits="src=prplicon" class="summaryIcon"/>
+          </xul:vbox>
+          <xul:vbox flex="1">
+            <xul:hbox align="baseline">
+              <xul:description xbl:inherits="value=username" class="summaryName"/>
+              <xul:separator flex="1" hidden="true"/>
+              <xul:checkbox label="&accountSummary.connectAutomatically.label;"
+                            dir="reverse" class="summaryAutologinCheckbox" hidden="true"
+                            anonid="autologin" checked="false"/>
+            </xul:hbox>
+            <xul:hbox align="center" class="textGroup">
+              <xul:label class="showChecked" value="&accountNew.doCreate.label;"/>
+              <xul:label class="hideChecked" value="&accountNew.noCreate.label;"/>
+            </xul:hbox>
+          </xul:vbox>
+        </xul:hbox>
+      </xul:vbox>
+    </content>
+    <implementation>
+      <property name="checked"
+                onget="return document.getAnonymousElementByAttribute(this,
+                                                  'anonid',
+                                                  'accountSelected').checked;"/>
+      <property name="protocolId"
+                onget="return this.getAttribute('protocolId');"
+                onset="return this.setAttribute('protocolId', val);"/>
+      <property name="password"
+                onget="return this.getAttribute('password');"
+                onset="return this.setAttribute('password', val);"/>
+      <property name="alias"
+                onget="return this.getAttribute('alias');"
+                onset="return this.setAttribute('alias', val);"/>
+      <property name="autologin"
+                onget="return document.getAnonymousElementByAttribute(this,
+                                                  'anonid',
+                                                  'autologin').checked;"/>
+      <method name="build">
+        <parameter name="aAccountObj"/>
+        <body>
+        <![CDATA[
+          let protoIcon = aAccountObj.proto.iconBaseURI + "icon32.png";
+          this.setAttribute("prplicon", protoIcon);
+          this.setAttribute("protocolId", aAccountObj.proto.id);
+          this.setAttribute("username", aAccountObj.username.value);
+          this.setAttribute("checked", true);
+
+          if (!aAccountObj.proto.noPassword && aAccountObj.password)
+            this.password = aAccountObj.password;
+          if (aAccountObj.alias)
+            this.alias = aAccountObj.alias;
+          this.options = aAccountObj.options;
+          this.proxy = aAccountObj.proxy;
+        ]]>
+        </body>
+      </method>
+      <method name="updateChecked">
+        <body>
+        <![CDATA[
+          let checkbox = document.getAnonymousElementByAttribute(this, "anonid",
+                                                                 "accountSelected");
+          this.setAttribute("checked", checkbox.checked);
+        ]]>
+        </body>
+      </method>
+    </implementation>
+  </binding>
+
 </bindings>
diff --git a/instantbird/content/accountWizard.xul b/instantbird/content/accountWizard.xul
--- a/instantbird/content/accountWizard.xul
+++ b/instantbird/content/accountWizard.xul
@@ -12,41 +12,52 @@
   <!ENTITY % accountWizardDTD SYSTEM "chrome://instantbird/locale/accountWizard.dtd">
   <!ENTITY % brandDTD SYSTEM "chrome://branding/locale/brand.dtd">
   %accountWizardDTD;
   %brandDTD;
 ]>
 
 <wizard id="accountWizard" title="&windowTitle.label;"
         windowtype="Messenger:accountWizard"
-        onwizardfinish="return accountWizard.createAccount();"
+        onwizardfinish="return accountWizard.createAccounts();"
         onload="accountWizard.onload();"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
   <script type="application/javascript" src="chrome://instantbird/content/accountWizard.js"/>
   <stringbundle id="proxiesBundle" src="chrome://instantbird/locale/proxies.properties"/>
   <stringbundle id="accountsBundle" src="chrome://instantbird/locale/accounts.properties"/>
-  <stringbundle id="topProtocolsBundle" src="chrome://instantbird/locale/accountWizard.properties"/>
+  <stringbundle id="accountWizardBundle" src="chrome://instantbird/locale/accountWizard.properties"/>
 
-  <wizardpage id="accountwelcome" pageid="accountwelcome" next="accounttoplist"
-              label="&accountWelcomeTitle.label;">
-    <description>&accountWelcomeInfo.label;</description>
-    <separator/>
+  <wizardpage id="accountwelcome" pageid="accountwelcome" next="accountsummary"
+              label="&accountWelcomeTitle.label;"
+              onpageshow="accountWizard.showWelcomePage();"
+              onpagehide="accountWizard.hideWelcomePage();"
+              onextra1="accountWizard.skipAccountImport();">
+    <description>&accountWelcomeInfo.label2;</description>
+    <separator class="thin"/>
+    <hbox id="importStatusBox" align="center">
+      <image id="accountSearchStatusImage" class="accountSearchSearching"/>
+      <description id="accountImportStatus" flex="1"/>
+    </hbox>
+    <separator flex="1"/>
+    <description id="accountSkipLabel">&accountWelcomeSkip.label;</description>
   </wizardpage>
 
   <wizardpage id="accounttoplist" pageid="accounttoplist" next="accountprotocol"
               label="&accountProtocolTitle.label;"
+              onpageshow="accountWizard.showTopProtocolPage();"
+              onpagerewound="accountWizard.rewindTopProtocolPage();"
               onpageadvanced="return accountWizard.advanceTopProtocolPage();">
     <description>&accountProtocolInfo.label2;</description>
     <separator class="thin"/>
     <richlistbox flex="1" id="topprotolist"
                  ondblclick="document.getElementById('accountWizard').advance();">
       <richlistitem id="otherListItem">
-        <label class="top-proto-name" value="&accountProtocolShowMore.label;"/>
-        <description class="top-proto-description" value="&accountProtocolShowMore.description;"/>
+        <label class="topProtoName" value="&accountProtocolShowMore.label;"/>
+        <description class="topProtoDescription" value="&accountProtocolShowMore.description;"/>
       </richlistitem>
     </richlistbox>
   </wizardpage>
 
   <wizardpage id="accountprotocol" pageid="accountprotocol" next="accountusername"
               label="&accountProtocolTitle.label;"
               onpageshow="accountWizard.showProtocolPage();"
               onpageadvanced="return accountWizard.selectProtocol();">
@@ -59,39 +70,42 @@
              onclick="if (event.button == 0) { accountWizard.openURL(this.getAttribute('getMoreURL')); }"/>
     </hbox>
   </wizardpage>
 
   <wizardpage id="accountusername" pageid="accountusername" next="accountpassword"
               label="&accountUsernameTitle.label;"
               onpageshow="accountWizard.showUsernamePage();"
               onpagehide="accountWizard.hideUsernamePage();"
-              onpagerewound="return accountWizard.rewindFromUsernamePage();">
+              onpageadvanced="accountWizard.advanceUsernamePage();">
     <description id="usernameInfo"/>
     <separator/>
     <vbox id="userNameBox"/>
     <separator/>
     <description id="duplicateAccount" hidden="true">&accountUsernameDuplicate.label;</description>
   </wizardpage>
 
   <wizardpage id="accountpassword" pageid="accountpassword" next="accountadvanced"
-              label="&accountPasswordTitle.label;">
+              label="&accountPasswordTitle.label;"
+              onpageshow="accountWizard.showPasswordPage();"
+              onpageadvanced="accountWizard.advancePasswordPage();">
     <description>&accountPasswordInfo.label;</description>
     <separator/>
     <hbox id="passwordBox" align="baseline">
       <label value="&accountPasswordField.label;" control="password" id="passwordLabel"/>
       <textbox id="password" type="password"/>
     </hbox>
     <separator/>
     <description id="passwordManagerDescription">&accountPasswordManager.label;</description>
   </wizardpage>
 
   <wizardpage id="accountadvanced" pageid="accountadvanced" next="accountsummary"
               label="&accountAdvancedTitle.label;"
-              onpageshow="accountWizard.showAdvanced();">
+              onpageshow="accountWizard.showAdvanced();"
+              onpageadvanced="accountWizard.advanceOptionsPage();">
     <description>&accountAdvancedInfo.label;</description>
     <separator class="thin"/>
     <groupbox id="aliasGroupbox" class="collapsable"
               onkeypress="accountWizard.onGroupboxKeypress(event)">
       <caption id="aliasGroupboxCaption" label="&accountAliasGroupbox.caption;"
                onclick="accountWizard.toggleGroupbox('aliasGroupbox')"/>
       <hbox id="aliasBox" align="baseline">
         <label value="&accountAliasField.label;" control="alias" id="aliasLabel"/>
@@ -121,23 +135,17 @@
                 accesskey="&accountProxySettings.change.accessKey;"
                 oncommand="accountWizard.openProxySettings();"/>
       </hbox>
     </groupbox>
   </wizardpage>
 
   <wizardpage id="accountsummary" pageid="accountsummary"
               label="&accountSummaryTitle.label;"
-              onpageshow="accountWizard.showSummary();">
-    <description>&accountSummaryInfo.label;</description>
-    <separator/>
-    <grid id="summarygrid" flex="1">
-      <columns>
-        <column/>
-        <column flex="1"/>
-      </columns>
-      <rows id="summaryRows"/>
-    </grid>
-    <separator/>
-    <checkbox id="connectNow" label= "&accountSummary.connectNow.label;" checked="true"/>
+              onextra2="accountWizard.addAnotherAccount();"
+              onpageshow="accountWizard.showSummary();"
+              onpagehide="accountWizard.hideSummary();">
+    <description>&accountSummaryInfo.label2;</description>
+    <separator class="thin"/>
+    <richlistbox id="accountSummaryList" flex="1"/>
   </wizardpage>
 
 </wizard>
diff --git a/instantbird/content/tabbrowser.css b/instantbird/content/tabbrowser.css
--- a/instantbird/content/tabbrowser.css
+++ b/instantbird/content/tabbrowser.css
@@ -48,8 +48,9 @@ tabconversation {
   display: none;
 }
 
 .tabs-newtab-button,
 #context_newTab,
 #context_newTabSeparator {
   display: none;
 }
+
diff --git a/instantbird/locales/en-US/chrome/instantbird/accountWizard.dtd b/instantbird/locales/en-US/chrome/instantbird/accountWizard.dtd
--- a/instantbird/locales/en-US/chrome/instantbird/accountWizard.dtd
+++ b/instantbird/locales/en-US/chrome/instantbird/accountWizard.dtd
@@ -1,16 +1,17 @@
 <!-- This Source Code Form is subject to the terms of the Mozilla Public
    - License, v. 2.0. If a copy of the MPL was not distributed with this
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
 
 <!ENTITY windowTitle.label            "Account Wizard">
 
-<!ENTITY accountWelcomeTitle.label   "Welcome">
-<!ENTITY accountWelcomeInfo.label    "This wizard will help you in the process of setting up your IM account in order to use it with &brandShortName;.">
+<!ENTITY accountWelcomeTitle.label    "Welcome">
+<!ENTITY accountWelcomeInfo.label2    "This wizard will guide you through configuring accounts for &brandShortName;.">
+<!ENTITY accountWelcomeSkip.label     "If you wish to create new accounts instead, press Skip.">
 
 <!ENTITY accountProtocolTitle.label   "Protocol">
 <!ENTITY accountProtocolInfo.label2   "Please choose the protocol of your IM account.">
 <!ENTITY accountProtocolGetMore.label "Get moreâ€¦">
 <!ENTITY accountProtocolShowMore.label  "Show all protocols">
 <!ENTITY accountProtocolShowMore.description  "Choose from the full list of protocols">
 
 <!ENTITY accountUsernameTitle.label   "Username">
@@ -26,11 +27,15 @@
 <!ENTITY accountAdvanced.newMailNotification.label   "Notify on new Mail">
 <!ENTITY accountAliasGroupbox.caption "Local Alias">
 <!ENTITY accountAliasField.label      "Alias:">
 <!ENTITY accountAliasInfo.label       "This will only be displayed in your conversations when you talk, remote buddies won't see it.">
 <!ENTITY accountProxySettings.caption "Proxy Settings">
 <!ENTITY accountProxySettings.change.label     "Changeâ€¦">
 <!ENTITY accountProxySettings.change.accessKey "C">
 
-<!ENTITY accountSummaryTitle.label   "Summary">
-<!ENTITY accountSummaryInfo.label    "A summary of the information you entered is displayed below. Please check it before the account is created.">
-<!ENTITY accountSummary.connectNow.label "Connect this account now.">
+<!ENTITY accountSummaryTitle.label    "Summary">
+<!ENTITY accountSummaryInfo.label2    "Here is a summary of the accounts that will be created.">
+<!ENTITY accountSummary.connectAutomatically.label "Connect automatically.">
+<!ENTITY accountExisting.doImport.label    "Will be imported from:">
+<!ENTITY accountExisting.noImport.label    "Will not be imported">
+<!ENTITY accountNew.doCreate.label    "Will be created">
+<!ENTITY accountNew.noCreate.label    "Will not be created">
diff --git a/instantbird/locales/en-US/chrome/instantbird/accountWizard.properties b/instantbird/locales/en-US/chrome/instantbird/accountWizard.properties
--- a/instantbird/locales/en-US/chrome/instantbird/accountWizard.properties
+++ b/instantbird/locales/en-US/chrome/instantbird/accountWizard.properties
@@ -14,8 +14,19 @@ topProtocol.list=prpl-gtalk,prpl-faceboo
 # These are the descriptions of the top protocols specified above.
 # A description should be provided for each protocol ID listed above.
 topProtocol.prpl-gtalk.description=Talk to your Gmail contacts
 topProtocol.prpl-facebook.description=Communicate with Facebook friends
 topProtocol.prpl-twitter.description=Stay up to date with your Twitter timeline
 topProtocol.prpl-aim.description=Chat with your buddies on AOL Instant Messenger
 topProtocol.prpl-msn.description=Microsoft Windows Live Messenger (formerly MSN)
 topProtocol.prpl-yahoo.description=Chat with friends using Yahoo! Messenger
+
+skipButton.label=Skip >
+skipButton.accessKey=S
+addButton.label=Add another account
+addButton.accessKey=A
+
+searchStatus.searching.label=Looking for existing accounts...
+searchStatus.success.label=Instantbird was able to find %S existing accounts on your computer. To view what was found, press Next.
+searchStatus.failure.label=Instantbird could not find any existing accounts to import. To configure a new account, press Next.
+
+summaryItem.clienttext.label=from %S
diff --git a/instantbird/test/xpcshell.ini b/instantbird/test/xpcshell.ini
--- a/instantbird/test/xpcshell.ini
+++ b/instantbird/test/xpcshell.ini
@@ -1,6 +1,7 @@
 ; This Source Code Form is subject to the terms of the Mozilla Public
 ; License, v. 2.0. If a copy of the MPL was not distributed with this
 ; file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 [include:chat/protocols/irc/test/xpcshell.ini]
+[include:chat/importers/test/xpcshell.ini]
 [include:purple/purplexpcom/src/test/xpcshell.ini]
diff --git a/instantbird/themes/accountWizard.css b/instantbird/themes/accountWizard.css
--- a/instantbird/themes/accountWizard.css
+++ b/instantbird/themes/accountWizard.css
@@ -2,45 +2,119 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #accountprotocol,
 #accountsummary {
   overflow: visible;
 }
 
-#summarygrid {
-  overflow: auto;
+#accountSummaryList {
+  background-color: ThreeDFace;
+}
+
+#accountSearchStatusImage {
+  width: 16px;
+  height: 16px;
+}
+
+#importStatusBox {
+  padding-left: 5px;
+  min-height: 3em;
 }
 
 #otherListItem {
   padding-left: 40px;
   min-height: 40px;
   -moz-box-orient: vertical;
   -moz-box-pack: center;
 }
 
-.top-proto-name, .top-proto-description {
+.existingAccount,
+.newAccount {
+  padding: 2px 0px;
+  min-height: 52px;
+  border-bottom: 1px solid ThreeDLightShadow;
+}
+
+.textGroup {
+  min-height: 31px;
+}
+
+.summaryName {
+  font-weight: bold;
+  margin-bottom: 0;
+}
+
+richlistitem[checked="false"] .summaryName,
+richlistitem[checked="false"] .hideChecked
+{
+  color: GrayText;
+}
+
+.summaryIcon {
+  margin-right: 2px;
+  width: 32px;
+  max-width: 32px;
+  height: 32px;
+  max-height: 32px;
+}
+
+richlistitem[checked="false"] .summaryIcon {
+  opacity: 0.3;
+}
+
+.summaryCheckbox {
+  margin-right: 0;
+  padding-right: 0;
+  padding-top: 10px;
+  padding-bottom: 10px;
+}
+
+.summaryImporterText,
+.summaryImporterList {
+ margin-left: 0;
+}
+
+.summaryAutologinCheckbox {
+  padding: 0 0;
+  margin: 0 0;
+}
+
+.topProtoName,
+.topProtoDescription {
   margin: 2px 2px;
   padding: 0px;
 }
 
-.top-proto-name {
+.topProtoName {
   font-size: larger;
 }
 
-.top-proto-description {
+.topProtoDescription {
   font-size: smaller;
   opacity: 0.85;
 }
 
-.top-proto-icon {
+.topProtoIcon {
   padding: 4px;
 }
 
+.accountSearchSearching {
+  list-style-image: url("chrome://global/skin/media/throbber.png");
+}
+
+.accountSearchSuccessful {
+  list-style-image: url("chrome://mozapps/skin/extensions/alerticon-info-positive.png");
+}
+
+.accountSearchFailure {
+  list-style-image: url("chrome://global/skin/icons/information-16.png");
+}
+
 groupbox.collapsable {
   -moz-user-focus: normal;
 }
 
 %ifdef XP_WIN
 groupbox.collapsable .caption-text {
   border: 1px solid transparent;
 }
@@ -78,13 +152,12 @@ groupbox.collapsable caption .caption-ic
   height: 9px;
   background-repeat: no-repeat;
   background-position: center;
   -moz-margin-start: 1px;
   -moz-margin-end: 3px;
   background-image: url("chrome://global/skin/tree/twisty-open.png");
 }
 
-
 groupbox.collapsable[closed="true"] caption .caption-icon {
   background-image: url("chrome://global/skin/tree/twisty-clsd.png");
 }
 %endif
diff --git a/tools/patches/Bug-781956-wizard-advance.patch b/tools/patches/Bug-781956-wizard-advance.patch
new file mode 100644
--- /dev/null
+++ b/tools/patches/Bug-781956-wizard-advance.patch
@@ -0,0 +1,22 @@
+diff --git a/toolkit/content/widgets/wizard.xml b/toolkit/content/widgets/wizard.xml
+--- a/toolkit/content/widgets/wizard.xml
++++ b/toolkit/content/widgets/wizard.xml
+@@ -262,17 +262,17 @@
+             return; 
+             
+           if (this.currentPage && !this._fireEvent(this.currentPage, "pagehide"))
+             return;
+             
+           if (this.currentPage && !this._fireEvent(this.currentPage, "pageadvanced"))
+             return;
+ 
+-          if (this.onLastPage) {
++          if (this.onLastPage && !aPageId) {
+             if (this._fireEvent(this, "wizardfinish"))
+               window.setTimeout(function() {window.close();}, 1);
+           } else {
+             if (!this._fireEvent(this, "wizardnext"))
+               return; 
+             
+             var page;
+             if (aPageId)
